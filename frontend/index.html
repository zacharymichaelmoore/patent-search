<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Patent Assistant</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: auto;
        background: whitesmoke;
        color: #111827;
        line-height: 1.6;
      }

      header {
        padding: 2rem 3rem 0rem 3rem;
      }

      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .btn-add-term {
        display: inline-flex;
        align-items: center;
        padding: 0.375rem 0.75rem;
        background: transparent;
        color: black;
        border: 1px dashed gainsboro;
        border-radius: 0.5rem;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.1s;
        font-family: serif;
      }

      .btn-add-term:hover {
        color: black;
        background-color: gainsboro;
        border: 1px solid gainsboro;
      }

      h1 {
        font-size: 3.5rem;
        font-family: auto;
        font-weight: 700;
        color: #111827;
        line-height: 113%;
      }

      h2 {
        font-family: sans-serif;
      }

      .subtitle {
        font-size: 1rem;
        color: gray;
        font-style: italic;
      }

      p {
        font-family: serif;
      }

      main {
        max-width: 1400px;
        margin: 1rem auto;
        padding: 2.5rem;
        padding-top: 1rem;
      }

      .grid {
        padding: 1rem;
        display: grid;
        grid-template-columns: 1fr 400px;
      }

      @media (max-width: 1024px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border-radius: 0.25rem;
        padding: 2rem 0rem;
      }

      .card-premium {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        margin-top: 1.5rem;
      }

      .card-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: default;
      }

      .input-section {
        margin-top: 1rem;
      }

      label {
        display: block;
        font-size: 1rem;
        font-weight: 500;
        color: gray;
        margin-bottom: 0.25rem;
      }

      .input-group {
        display: flex;
        gap: 0.5rem;
      }

      input[type="text"],
      textarea {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid ghostwhite;
        border-radius: 0.5rem;
        font-size: 1rem;
        font-family: inherit;
        transition: border-color 0.1s;
      }

      textarea {
        min-height: 128px;
        height: auto;
        resize: none;
        background: white;
        border-radius: 0;
        overflow: hidden;
      }

      input:focus,
      textarea:focus {
        outline: none;
        border-color: #3b82f6;
      }

      input[type="number"] {
        width: 100%;
        padding: 0.5rem 0.75rem;
        border: 1px solid transparent;
        border-radius: 0.375rem;
        font-size: 1rem;
        background: gainsboro;
        cursor: not-allowed;
      }

      button {
        padding: 0.5rem 1rem;
        border: none;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.1s;
      }

      .btn-primary {
        color: black;
        background-color: none;
        border-radius: 0.5rem;
        border: 1px dashed gainsboro;
        font-family: serif;
      }

      .btn-primary:hover:not(:disabled) {
        background: gainsboro !important;
        transition: all 0.1s;
        border: 1px dashed gainsboro;
      }

      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: white;
        border: 1px solid #d1d5db;
        color: #374151;
      }

      .btn-secondary:hover {
        background: #f9fafb;
      }

      .btn-premium {
        background: white;
        color: #667eea;
        font-weight: 600;
        font-size: 1rem;
        padding: 1rem 1.5rem;
      }

      .btn-premium:hover {
        transform: translateY(-2px);
      }

      .btn-large {
        width: 100%;
        padding: 0.75rem;
        font-size: 1rem;
      }

      .btn-large:hover:not(:disabled) {
        background: coral !important;
        color: white;
        border: 1px solid white;
        transition: all 0.2s;
        font-family: serif;
      }

      .query-section {
        background: transparent;
      }

      .query-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: gray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-decoration: underline;
      }

      .terms-section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .terms-container {
        align-items: flex-start;
        display: flex;
        flex-wrap: wrap;
      }

      .term-badge {
        display: inline-flex;
        align-items: center;
        color: black;
        border-radius: 9999px;
        font-size: 1rem;
        position: relative;
        cursor: pointer;
        transition: all 0.1s;
        user-select: none;
      }

      .term-badge:hover {
        transform: scale(1.05);
        padding-left: 1.75rem;
      }

      .popover .hidden {
        display: none;
      }

      .term-remove {
        position: absolute;
        left: 0.35rem;
        width: 1.25rem;
        height: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.1s;
        font-size: 1.1rem;
        line-height: 1;
      }

      .term-badge:hover .term-remove {
        opacity: 1;
      }

      .term-remove:hover {
        color: #ef4444;
      }

      .popover {
        position: absolute;
        z-index: 1000;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1rem;
        min-width: 250px;
        max-width: 350px;
        display: none;
      }

      .popover.show {
        display: block;
      }

      .popover-title {
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 0.5rem;
      }

      .popover-subtitle {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.75rem;
      }

      .related-terms {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .related-badge {
        padding: 0.25rem 0.6rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 9999px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.1s;
        position: relative;
        padding-left: 1.5rem;
      }

      .related-badge:hover {
        background: #f0f9ff;
        border-color: #3b82f6;
        transform: scale(1.05);
      }

      .related-badge::before {
        content: "+";
        position: absolute;
        left: 0.4rem;
        font-weight: bold;
        color: #3b82f6;
      }

      .operator {
        padding-top: 2px;
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        letter-spacing: 0.05em;
        font-family: "Courier New", monospace;
      }

      .operator-and {
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-align: center;
      }

      .loading-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.75rem;
        color: #6b7280;
      }
      .progress-container {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }
      .progress-track {
        position: relative;
        height: 0.5rem;
        border-radius: 9999px;
        background: #e5e7eb;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #3b82f6, #2563eb);
        border-radius: inherit;
        transition: width 0.2s ease-out;
      }
      .progress-message {
        font-size: 0.75rem;
        color: #4b5563;
        text-align: center;
      }

      .spinner-small {
        width: 1rem;
        height: 1rem;
        border: 2px solid #e5e7eb;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      .results-container {
        margin-top: 1.5rem;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 1.5rem;
      }

      .result-item {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1.25rem;
        margin-bottom: 1rem;
      }

      .result-item:last-child {
        margin-bottom: 0;
      }

      .result-title {
        font-weight: 600;
        color: #111827;
      }

      .result-abstract {
        font-size: 1rem;
        color: #6b7280;
        margin-bottom: 0.5rem;
      }

      .result-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .result-link {
        color: #3b82f6;
        text-decoration: none;
        font-size: 1rem;
      }

      .result-link:hover {
        text-decoration: underline;
      }

      .loading {
        text-align: center;
        padding: 2rem;
        color: #6b7280;
      }

      .spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        border: 3px solid #e5e7eb;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: gray;
        font-size: 1rem;
        border: 2px dashed #e5e7eb;
        border-radius: 0.5rem;
      }

      .hidden {
        display: none;
      }

      .score-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .score-low {
        background: #dbeafe;
        color: #1e40af;
      }
      .score-medium {
        background: #fef3c7;
        color: #92400e;
      }
      .score-high {
        background: #fecaca;
        color: #991b1b;
      }

      /* Premium Card Styles */
      .premium-icon {
        font-size: 3rem;
        text-align: center;
        margin-bottom: 1rem;
      }

      .premium-price {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin: 1rem 0;
      }

      .premium-price small {
        font-size: 1rem;
        font-weight: 400;
        opacity: 0.9;
      }

      .premium-features {
        list-style: none;
        margin: 1.5rem 0;
      }

      .premium-features li {
        padding: 0.5rem 0;
        padding-left: 1.5rem;
        position: relative;
      }

      .premium-features li::before {
        content: "âœ“";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #a5f3fc;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-content">
        <div>
          <h1>Prior Art Research Tool</h1>
          <p class="subtitle">
            Secure and Instant Research for Patent Applications
          </p>
        </div>
      </div>
    </header>

    <main>
      <div class="grid">
        <!-- Left: Description Editor -->
        <div class="card">
          <h2 class="card-title">Description</h2>

          <div id="promptSection">
            <label for="promptInput">Title</label>
            <div class="input-group">
              <input
                type="text"
                id="promptInput"
                placeholder="Enter invention title"
              />
              <button
                class="btn-primary"
                style="width: -webkit-fill-available; max-width: fit-content"
                onclick="generateDescription()"
                id="generateBtn"
              >
                Generate
              </button>
            </div>
          </div>

          <div class="input-section">
            <label for="userDescription">Description</label>
            <textarea
              id="userDescription"
              placeholder="Enter description or it will be auto-generated"
            ></textarea>
          </div>
        </div>

        <!-- Right Column -->
        <div style="padding-left: 1rem">
          <!-- Query Builder -->
          <div class="card">
            <h2 class="card-title">
              <span style="cursor: default">Related Terms</span>
              <span id="extractingIndicator" class="loading-indicator hidden">
                <div class="spinner-small"></div>
                <span>Analyzing...</span>
              </span>
            </h2>

            <div id="queryBuilder">
              <div id="emptyState" class="empty-state">
                <p style="cursor: default">Keywords will be generated here</p>
              </div>

              <div
                id="queryPreview"
                class="hidden"
                style="padding: 1.5rem; border: 1px solid gainsboro"
              >
                <div class="query-section">
                  <div class="query-label">Devices / Technologies</div>
                  <div class="terms-section">
                    <div class="terms-container" id="deviceTechTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addDeviceTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>

                <div id="andOperator" class="operator-and hidden">AND</div>

                <div class="query-section" id="subjectSection">
                  <div class="query-label">Subjects</div>
                  <div class="terms-section">
                    <div class="terms-container" id="subjectTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addSubjectTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <div class="input-section">
              <label for="maxDisplayResults"> Number of Results </label>
              <input
                type="text"
                id="maxDisplayResults"
                value="50"
                readonly
                title="Free tier limited to 50 results"
              />
            </div>
            <button
              class="btn-primary btn-large"
              onclick="startSearch()"
              id="searchButton"
              style="margin-top: 1rem"
            >
              Search
            </button>
            <div id="searchProgress" class="progress-container hidden">
              <div class="progress-track">
                <div id="searchProgressBar" class="progress-bar"></div>
              </div>
              <div id="searchProgressMessage" class="progress-message"></div>
            </div>
            <p
              id="searchStatusMessage"
              class="hidden"
              style="
                text-align: center;
                margin-top: 0.75rem;
                color: #6b7280;
                font-size: 0.875rem;
              "
            ></p>
          </div>

          <!-- Premium Upgrade Card -->
          <!-- <div class="card card-premium">
          <div class="premium-icon">ðŸš€</div>
          <h2 class="card-title" style="color: white; justify-content: center;">
            Unlock Detailed Analysis
          </h2>
          
          <div class="premium-price">
            $19.99
            <small>one-time</small>
          </div>

          <ul class="premium-features">
            <li><strong>AI-Powered Risk Scoring</strong> - Each patent analyzed with similarity scores (0-100)</li>
            <li><strong>Risk Level Classification</strong> - Low/Medium/High/Critical ratings for quick triage</li>
            <li><strong>Expert Reasoning</strong> - AI explains WHY each patent is relevant to your invention</li>
            <li><strong>Unlimited Results</strong> - Search up to 2,000 patents (vs 10 free)</li>
            <li><strong>Detailed CSV Export</strong> - Download comprehensive report with all analysis</li>
            <li><strong>Google Patents Links</strong> - Direct links to full patent documents</li>
            <li><strong>Priority Support</strong> - Get help from our patent search experts</li>
          </ul>

          <button class="btn-premium btn-large" onclick="unlockPremium()">
            ðŸ”“ Unlock Full Analysis - $19.99
          </button>

          <p style="text-align: center; margin-top: 1rem; font-size: 0.75rem; opacity: 0.9;">
            Secure payment via Stripe â€¢ Instant access â€¢ No subscription
          </p>
        </div> -->
        </div>
      </div>
      <button
        class="btn-secondary btn-large hidden"
        onclick="downloadCSV()"
        id="downloadButton"
      >
        Download .csv
      </button>
      <div id="resultsContainer" class="results-container hidden"></div>
    </main>

    <div id="termPopover" class="popover">
      <div id="popoverHoverTitle">
        <div class="popover-title">Related Terms</div>
        <div class="popover-subtitle">Click to add synonyms</div>
      </div>

      <div id="popoverAddSection" class="hidden">
        <div class="popover-title">Add New Term</div>
        <div class="input-group">
          <input
            type="text"
            id="addTermInput"
            placeholder="Type a term..."
            style="padding: 0.5rem"
          />
        </div>
        <div class="popover-subtitle" style="margin-top: 0.5rem">
          Suggestions will appear below. Press Enter to add.
        </div>
      </div>

      <div id="relatedTermsContainer" class="related-terms"></div>
    </div>

    <script>
      let eventSource = null;
      let extractTimeout = null;
      let currentTerms = {
        deviceTerms: [],
        technologyTerms: [],
        subjectTerms: [],
      };
      let relatedTermsCache = {};
      let currentHoverTerm = null;
      let popoverTimeout = null;
      let lastSearchQuery = "";
      let lastTopK = 100;
      let scoreThreshold = 90;
      let popoverContext = {
        mode: null, // 'hover' or 'add'
        category: null, // 'device' or 'subject'
      };
      let addTermDebounceTimeout = null;
      let progressTotalCandidates = null;
      let progressAnalyzedCount = 0;
      let currentProgressPercent = 0;
      let latestProgressMessage = "";
      let progressHideTimeout = null;
      const addTermButtons = {
        device: document.getElementById("addDeviceTermButton"),
        subject: document.getElementById("addSubjectTermButton"),
      };

      Object.entries(addTermButtons).forEach(([category, button]) => {
        if (!button) return;
        button.addEventListener("click", (e) =>
          showAddTermPopover(e.currentTarget, category)
        );
      });

      function autoResizeDescription(element) {
        if (!element) return;
        element.style.height = "auto";
        element.style.height = `${element.scrollHeight}px`;
      }

      autoResizeDescription(document.getElementById("userDescription"));

      // TODO: Replace with your actual Stripe checkout URL
      const STRIPE_CHECKOUT_URL = "https://buy.stripe.com/YOUR_CHECKOUT_LINK";

      function unlockPremium() {
        window.location.href = STRIPE_CHECKOUT_URL;
      }

      async function generateDescription() {
        const prompt = document.getElementById("promptInput").value.trim();
        const textarea = document.getElementById("userDescription");
        const btn = document.getElementById("generateBtn");

        if (!prompt) {
          alert("Please enter a brief description of your invention.");
          return;
        }

        btn.disabled = true;
        btn.textContent = "Generating...";
        textarea.value = "";
        autoResizeDescription(textarea);

        try {
          const response = await fetch("/api/generate-description", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
          });

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            textarea.value += decoder.decode(value);
            autoResizeDescription(textarea);
            textarea.scrollTop = textarea.scrollHeight;
          }

          extractTerms(textarea.value);
        } catch (err) {
          console.error("Error:", err);
          alert("Failed to generate description");
        } finally {
          btn.disabled = false;
          btn.textContent = "Generate";
        }
      }

      document
        .getElementById("userDescription")
        .addEventListener("input", (e) => {
          autoResizeDescription(e.target);
          clearTimeout(extractTimeout);
          extractTimeout = setTimeout(() => {
            extractTerms(e.target.value);
          }, 2000);
        });

      async function extractTerms(text) {
        if (!text || text.trim().length < 20) {
          currentTerms = {
            deviceTerms: [],
            technologyTerms: [],
            subjectTerms: [],
          };
          updateQueryPreview();
          return;
        }

        document
          .getElementById("extractingIndicator")
          .classList.remove("hidden");

        try {
          const response = await fetch("/api/extract-terms", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ documentText: text }),
          });

          if (response.ok) {
            currentTerms = await response.json();
            updateQueryPreview();
            preloadRelatedTerms();
          }
        } catch (err) {
          console.error("Error:", err);
        } finally {
          document
            .getElementById("extractingIndicator")
            .classList.add("hidden");
        }
      }

      async function preloadRelatedTerms() {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];

        const termsToFetch = allTerms.filter((t) => !relatedTermsCache[t]);
        if (termsToFetch.length === 0) return;

        try {
          const response = await fetch("/api/get-related-terms", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: termsToFetch }),
          });

          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn("Failed to fetch related terms:", err);
        }
      }

      function formatProgressMessage(message) {
        if (!message) return "";
        return message.replace(/^\[[^\]]+\]\s*/, "").trim();
      }

      function setSearchProgress(percent, message) {
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;

        if (Number.isFinite(percent)) {
          currentProgressPercent = Math.max(
            0,
            Math.min(100, Math.round(percent))
          );
        }

        if (message) {
          latestProgressMessage = formatProgressMessage(message);
        }

        bar.style.width = `${currentProgressPercent}%`;
        text.textContent = latestProgressMessage;
        container.classList.remove("hidden");
      }

      function resetSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        progressTotalCandidates = null;
        progressAnalyzedCount = 0;
        currentProgressPercent = 0;
        latestProgressMessage = "Starting search...";
        setSearchProgress(5, latestProgressMessage);
      }

      function hideSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;
        currentProgressPercent = 0;
        latestProgressMessage = "";
        bar.style.width = "0%";
        text.textContent = "";
        container.classList.add("hidden");
      }

      function updateSearchProgressFromLog(message) {
        if (!message) return;
        const cleanMessage = formatProgressMessage(message);
        let percent = null;

        if (/starting embedding/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 5);
        } else if (/finding candidate/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 12);
        } else if (/found\s+(\d+)\s+candidates?/i.test(cleanMessage)) {
          const match = cleanMessage.match(/found\s+(\d+)\s+candidates?/i);
          if (match) {
            progressTotalCandidates = parseInt(match[1], 10) || null;
            progressAnalyzedCount = 0;
          }
          percent = Math.max(currentProgressPercent, 20);
        } else if (/processed\s+(\d+)\s*\/\s*(\d+)/i.test(cleanMessage)) {
          const match = cleanMessage.match(/processed\s+(\d+)\s*\/\s*(\d+)/i);
          if (match) {
            progressAnalyzedCount = parseInt(match[1], 10) || 0;
            const total = parseInt(match[2], 10) || progressTotalCandidates;
            if (total) {
              progressTotalCandidates = total;
              const ratio = Math.max(
                0,
                Math.min(1, progressAnalyzedCount / total)
              );
              percent = Math.max(currentProgressPercent, 20 + ratio * 75);
            }
          }
        } else if (/finished analysis/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 95);
        }

        setSearchProgress(percent, cleanMessage);
      }

      function handleSearchComplete(data) {
        let message = "Search complete";
        if (data && typeof data.analyzed === "number") {
          progressAnalyzedCount = data.analyzed;
        }
        if (data && typeof data.results === "number") {
          message = `${message} - ${data.results} result${
            data.results === 1 ? "" : "s"
          }`;
        }
        if (progressTotalCandidates && progressAnalyzedCount) {
          message = `${message} (${progressAnalyzedCount} analyzed)`;
        }

        setSearchProgress(100, message);
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
        }
        progressHideTimeout = setTimeout(() => {
          hideSearchProgress();
          progressHideTimeout = null;
        }, 1200);
      }

      function updateQueryPreview() {
        const hasTerms =
          currentTerms.deviceTerms.length > 0 ||
          currentTerms.technologyTerms.length > 0 ||
          currentTerms.subjectTerms.length > 0;

        document
          .getElementById("emptyState")
          .classList.toggle("hidden", hasTerms);
        document
          .getElementById("queryPreview")
          .classList.toggle("hidden", !hasTerms);

        const combinedTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
        ];
        renderTerms("deviceTechTerms", combinedTerms, "device");
        renderTerms("subjectTerms", currentTerms.subjectTerms, "subject");

        document
          .getElementById("andOperator")
          .classList.toggle(
            "hidden",
            combinedTerms.length === 0 || currentTerms.subjectTerms.length === 0
          );
      }

      function renderTerms(containerId, terms, category) {
        const container = document.getElementById(containerId);
        container.innerHTML = "";

        if (terms.length > 0) {
          terms.forEach((term, index) => {
            const badge = document.createElement("span");
            badge.className = "term-badge";
            badge.innerHTML = `<span class="term-remove" onclick="removeTerm('${term}')">Ã—</span>${term}`;
            badge.addEventListener("mouseenter", (e) =>
              showHoverPopover(e.currentTarget, term)
            );
            badge.addEventListener("mouseleave", hidePopover);
            if (index < terms.length - 1) {
              badge.insertAdjacentText("beforeend", ", ");
            }
            container.appendChild(badge);
          });
        } else {
          container.innerHTML =
            '<span style="color: #9ca3af; font-size: 1rem;">No terms</span>';
        }

        const addButton = addTermButtons[category];
        if (addButton) {
          addButton.classList.remove("hidden");
        }
      }

      function positionPopover(targetElement) {
        const popover = document.getElementById("termPopover");
        if (!targetElement || !popover) return;

        const rect = targetElement.getBoundingClientRect();
        const scrollX = window.scrollX;
        const scrollY = window.scrollY;

        const top = rect.bottom + scrollY + 10;
        const left = rect.left + scrollX;

        popover.style.left = `${left}px`;
        popover.style.top = `${top}px`;
      }

      function showAddTermPopover(buttonElement, category) {
        clearTimeout(popoverTimeout);
        popoverContext = { mode: "add", category: category };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const input = document.getElementById("addTermInput");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.add("hidden");
        addSection.classList.remove("hidden");
        relatedContainer.innerHTML = "";
        input.value = "";

        positionPopover(buttonElement);

        popover.classList.add("show");
        input.focus();

        input.oninput = () => {
          clearTimeout(addTermDebounceTimeout);
          addTermDebounceTimeout = setTimeout(() => {
            const term = input.value.trim();
            if (term) {
              fetchAndDisplayRelated(term, relatedContainer);
            } else {
              relatedContainer.innerHTML = "";
            }
          }, 500);
        };

        // This is the improved part
        input.onkeydown = (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const term = input.value.trim();
            if (term) {
              addRelatedTerm(term);
              hidePopover(); // Close the popover on success
            }
          }
        };

        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      async function fetchAndDisplayRelated(term, container) {
        container.innerHTML =
          '<span style="font-size: 0.75rem; color: #9ca3af;">Loadingâ€¦</span>';

        if (!relatedTermsCache[term]) {
          await fetchRelatedForSingleTerm(term);
        }

        const related = relatedTermsCache[term] || [];
        container.innerHTML = "";

        if (related.length === 0) {
          container.innerHTML =
            '<span style="font-size: 0.75rem; color: #9ca3af;">No suggestions found.</span>';
        } else {
          related.forEach((relTerm) => {
            const badge = document.createElement("span");
            badge.className = "related-badge";
            badge.textContent = relTerm;
            badge.onclick = () => addRelatedTerm(relTerm);
            container.appendChild(badge);
          });
        }
      }

      function showHoverPopover(badgeElement, term) {
        clearTimeout(popoverTimeout);
        currentHoverTerm = term;
        popoverContext = { mode: "hover" };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.remove("hidden");
        addSection.classList.add("hidden");

        positionPopover(badgeElement);

        fetchAndDisplayRelated(term, relatedContainer);

        popover.classList.add("show");
        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      function hidePopover() {
        popoverTimeout = setTimeout(() => {
          document.getElementById("termPopover").classList.remove("show");
        }, 200);
      }

      async function fetchRelatedForSingleTerm(term) {
        if (relatedTermsCache[term]) return;
        try {
          const response = await fetch("/api/get-related-terms", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: [term] }),
          });
          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn(`Failed to fetch related terms for ${term}:`, err);
        }
      }

      function addRelatedTerm(term) {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];
        if (allTerms.includes(term)) {
          return;
        }

        if (popoverContext.mode === "add") {
          if (popoverContext.category === "subject") {
            currentTerms.subjectTerms.push(term);
          } else if (popoverContext.category === "device") {
            currentTerms.deviceTerms.push(term);
          } else {
            console.error(
              "addRelatedTerm called in 'add' mode with unknown category:",
              popoverContext.category
            );
            return;
          }
        } else if (popoverContext.mode === "hover" && currentHoverTerm) {
          if (
            currentTerms.deviceTerms.includes(currentHoverTerm) ||
            currentTerms.technologyTerms.includes(currentHoverTerm)
          ) {
            currentTerms.deviceTerms.push(term);
          } else if (currentTerms.subjectTerms.includes(currentHoverTerm)) {
            currentTerms.subjectTerms.push(term);
          }
        } else {
          console.error(
            "addRelatedTerm called in an unknown or invalid state:",
            popoverContext
          );
          return;
        }

        updateQueryPreview();

        if (popoverContext.mode === "hover") {
          hidePopover();
        }
      }

      function removeTerm(term) {
        currentTerms.deviceTerms = currentTerms.deviceTerms.filter(
          (t) => t !== term
        );
        currentTerms.technologyTerms = currentTerms.technologyTerms.filter(
          (t) => t !== term
        );
        currentTerms.subjectTerms = currentTerms.subjectTerms.filter(
          (t) => t !== term
        );
        updateQueryPreview();
      }

      function cleanTextForSearch(text) {
        return text
          .replace(/^#+\s+/gm, "")
          .replace(/\*\*/g, "")
          .replace(/\*/g, "")
          .replace(/__/g, "")
          .replace(/_/g, "")
          .replace(/^\d+\.\s+/gm, "")
          .replace(/^[-â€¢]\s+/gm, "")
          .replace(/\n\n+/g, " ")
          .replace(/\n/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function restoreSearchButton(button) {
        if (!button) return;
        button.disabled = false;
        button.innerHTML = "Search";
        button.style.display = "";
        button.style.alignItems = "";
        button.style.justifyContent = "";
        button.style.gap = "";
      }

      async function startSearch() {
        const maxDisplayResultsInput = document.getElementById("maxDisplayResults");
        if (!maxDisplayResultsInput) {
          alert("Error: Could not find the 'topK' input element.");
          return;
        }
        const maxDisplayResults = parseInt(maxDisplayResultsInput.value, 10);

        const resultsContainer = document.getElementById("resultsContainer");
        const searchButton = document.getElementById("searchButton");
        const downloadButton = document.getElementById("downloadButton");
        const searchStatusMessage = document.getElementById(
          "searchStatusMessage"
        );

        if (
          !resultsContainer ||
          !searchButton ||
          !downloadButton ||
          !searchStatusMessage
        ) {
          console.error("Missing required elements");
          alert(
            "A critical UI element is missing. Please check the console for details."
          );
          return;
        }

        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }

        // 1. Reset status message from previous search
        searchStatusMessage.classList.add("hidden");
        searchStatusMessage.textContent = "";

        // 2. Update button to show spinner and new text
        searchButton.disabled = true;
        searchButton.innerHTML = `
    <div class="spinner-small"></div>
    <span>Loading...</span>
  `;
        // Add flex styles to center the content
        searchButton.style.display = "flex";
        searchButton.style.alignItems = "center";
        searchButton.style.justifyContent = "center";
        searchButton.style.gap = "0.5rem";

        let searchQuery = "";
        const { deviceTerms, technologyTerms, subjectTerms } = currentTerms;
        const hasExtractedTerms =
          deviceTerms.length > 0 ||
          technologyTerms.length > 0 ||
          subjectTerms.length > 0;

        if (hasExtractedTerms) {
          const queryParts = [];
          const combinedTech = [...deviceTerms, ...technologyTerms];
          if (combinedTech.length > 0) {
            queryParts.push(
              `A patent describing a device or technology such as: ${combinedTech.join(
                " or "
              )}.`
            );
          }
          if (subjectTerms.length > 0) {
            queryParts.push(
              `Applied in the subject matter or field of: ${subjectTerms.join(
                " or "
              )}.`
            );
          }
          searchQuery = queryParts.join(" ");
        } else {
          const description = document
            .getElementById("userDescription")
            .value.trim();
          if (!description) {
            alert("You must generate terms from invention title first.");
            restoreSearchButton(searchButton);
            return;
          }
          searchQuery = cleanTextForSearch(description);
        }

        if (!searchQuery) {
          alert(
            "Could not build a search query. Please check your description."
          );
          restoreSearchButton(searchButton);
          return;
        }

        console.log("Final Search Query:", searchQuery);
        lastSearchQuery = searchQuery;
        lastTopK = maxDisplayResults;

        downloadButton.classList.add("hidden");
        resultsContainer.classList.remove("hidden");
        resultsContainer.innerHTML =
          '<div class="loading"><div class="spinner"></div><p>Searching patents...</p></div>';
        resetSearchProgress();

        let resultCount = 0;
        let hasClearedPlaceholder = false;
        let hasCompleted = false;

        const params = new URLSearchParams({
          userDescription: searchQuery,
          maxDisplayResults: String(maxDisplayResults),
        });

        eventSource = new EventSource(`/api/search?${params.toString()}`);

        eventSource.addEventListener("log", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            updateSearchProgressFromLog(data.message || "");
          } catch (err) {
            console.warn("Failed to parse log event", err);
          }
        });

        eventSource.addEventListener("result", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            const resultPayload = data.result;
            if (
              !resultPayload ||
              resultPayload.score === null ||
              resultPayload.score === undefined ||
              resultPayload.score < scoreThreshold
            ) {
              return;
            }

            if (!hasClearedPlaceholder) {
              resultsContainer.innerHTML = "";
              hasClearedPlaceholder = true;
            }

            if (addResult(resultPayload)) {
              resultCount++;
              searchStatusMessage.classList.add("hidden");
            }
          } catch (err) {
            console.warn("Failed to process result event", err);
          }
        });

        eventSource.addEventListener("complete", (event) => {
          if (hasCompleted) return;
          hasCompleted = true;

          let data = null;
          try {
            data = JSON.parse(event.data || "{}");
            handleSearchComplete(data);
          } catch (err) {
            console.warn("Failed to parse complete event", err);
            hideSearchProgress();
          }

          restoreSearchButton(searchButton);

          if (resultCount > 0) {
            if (data && typeof data.score_threshold === "number") {
              scoreThreshold = data.score_threshold;
            }
            const highConfidenceCount =
              data && typeof data.high_confidence === "number"
                ? data.high_confidence
                : resultCount;
            const totalCandidates =
              data && typeof data.total_candidates === "number"
                ? data.total_candidates
                : highConfidenceCount;
            searchStatusMessage.textContent = `Showing ${resultCount} with a score of ${scoreThreshold}+ (analyzed) out of ${highConfidenceCount} high-confidence matches from ${totalCandidates} initial candidates.`;
            downloadButton.classList.remove("hidden");
          } else {
            searchStatusMessage.textContent =
              `No results found with a score of ${scoreThreshold} or above.`;
            resultsContainer.innerHTML =
              `<div class="empty-state">No results found with a score of ${scoreThreshold} or above.</div>`;
          }
          searchStatusMessage.classList.remove("hidden");

          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        });

        eventSource.onerror = (event) => {
          if (hasCompleted) return;
          console.error("Search stream error:", event);
          hideSearchProgress();
          restoreSearchButton(searchButton);
          resultsContainer.innerHTML =
            '<div class="empty-state">An error occurred during the search. Please check the console.</div>';
          searchStatusMessage.textContent = "Search failed. Please try again.";
          searchStatusMessage.classList.remove("hidden");
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        };
      }

      function addResult(result) {
        // Only add the result if it meets the active score threshold
        const numericScore =
          typeof result.score === "number"
            ? result.score
            : Number.parseFloat(result.score);

        if (
          Number.isNaN(numericScore) ||
          numericScore === null ||
          numericScore === undefined ||
          numericScore < scoreThreshold
        ) {
          return false; // Indicate that the result was not added
        }

        const resultsContainer = document.getElementById("resultsContainer");
        if (!resultsContainer) return false;

        const existingCards =
          resultsContainer.querySelectorAll(".result-item").length;
        if (existingCards >= lastTopK) {
          return false;
        }

        let scoreClass = "score-low";
        if (numericScore >= 95) {
          scoreClass = "score-high";
        } else if (numericScore >= scoreThreshold) {
          scoreClass = "score-medium";
        }

        const displayScore = Number.isInteger(numericScore)
          ? numericScore
          : numericScore.toFixed(2);

        const scoreDisplay =
          numericScore !== null && numericScore !== undefined
            ? `<span class="score-badge ${scoreClass}">${displayScore}</span>`
            : "";

        const resultHTML = `
    <div class="result-item">
      <div class="result-title">
        ${result.title || "Untitled Patent"}
      </div>
      ${scoreDisplay}
      <div class="result-abstract" style="margin-bottom: 0.75rem;">
        ${result.preview || result.abstract || "No abstract available"}
      </div>
      <div class="result-meta" style="margin-bottom: 0.5rem;">
        <span>${result.patentNumber} â€¢ ${result.filingDate}</span>
      </div>
      ${
        result.googlePatentUrl
          ? `<a href="${result.googlePatentUrl}" target="_blank" class="result-link">View Full Patent on Google Patents â†’</a>`
          : ""
      }
    </div>
  `;
        resultsContainer.insertAdjacentHTML("beforeend", resultHTML);
        return true;
      }
      function downloadCSV() {
        const url = `/export_csv?userDescription=${encodeURIComponent(
          lastSearchQuery
        )}&topK=${lastTopK}`;
        window.open(url, "_blank");
      }

      document
        .getElementById("promptInput")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            generateDescription();
          }
        });

      document
        .getElementById("userDescription")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter" && e.ctrlKey) {
            startSearch();
          }
        });
    </script>
  </body>
</html>
