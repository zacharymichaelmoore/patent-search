<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Patent Assistant</title>
    <link
      rel="stylesheet"
      href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: auto;
        background: whitesmoke;
        color: #111827;
        line-height: 1.6;
      }

      header {
        padding: 2rem 5.5rem;
        display: none;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateY(-20px);
        transition: opacity 0.4s ease-in, transform 0.4s ease;
      }

      header.content-visible {
        display: block;
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateY(0);
      }

      .toastui-editor-defaultUI {
        border-color: transparent;
      }

      .toastui-editor-defaultUI-toolbar {
        background-color: transparent;
        border: none;
        border-radius: 0px;
      }

      .toastui-editor-toolbar-icons {
        border: none !important;
      }

      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .btn-add-term {
        display: inline-flex;
        align-items: center;
        padding: 0.375rem 0.75rem;
        background: transparent;
        color: black;
        border: 1px solid gainsboro;
        border-radius: 0.5rem;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.1s;
        font-family: serif;
      }

      .btn-add-term:hover {
        color: black;
        background-color: gainsboro;
        border: 1px solid gainsboro;
      }

      h1 {
        font-size: 3.5rem;
        font-family: auto;
        font-weight: 700;
        color: #111827;
        line-height: 113%;
      }

      h2 {
        font-family: sans-serif;
      }

      .subtitle {
        font-size: 1rem;
        color: gray;
        font-style: italic;
      }

      p {
        font-family: serif;
      }

      main {
        padding: 0;
        opacity: 1;
        transform: none;
        transition: opacity 0.4s ease, transform 0.4s ease, padding 0.4s ease;
      }

      main.app-visible {
        padding: 0 2.5rem 2rem;
      }

      .initial-center {
        min-height: calc(100vh - 4rem);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
      }

      .initial-center .card {
        max-width: 540px;
        width: 100%;
      }

      .fade-out {
        opacity: 0 !important;
        transform: translateY(-20px);
        pointer-events: none;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      .fade-in {
        animation: fadeInUp 0.5s ease forwards;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .grid {
        padding: 0 3rem 0;
        display: grid;
        grid-template-columns: 1fr 450px;
      }

      @media (max-width: 1024px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border-radius: 0.25rem;
        padding: 2rem 0rem;
      }

      .card-premium {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        margin-top: 1.5rem;
      }

      .card-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: default;
      }

      .input-section {
        margin-top: 1rem;
      }

      label {
        display: block;
        font-size: 1rem;
        font-weight: 500;
        color: gray;
        margin-bottom: 0.25rem;
      }

      #descriptionEditor {
        margin-top: 0.5rem;
      }

      .landing-header-text {
        text-align: center;
        margin-bottom: 0.5rem;
      }

      .landing-header-text h1 {
        font-size: 2.75rem;
        font-weight: 700;
      }

      .landing-header-text .subtitle {
        font-size: 1rem;
        color: gray;
        font-style: italic;
      }

      #promptSection {
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      #promptSection.prompt-inline {
        margin-bottom: 1.5rem;
      }

      .input-group {
        display: flex;
        gap: 0.5rem;
      }
      .input-group[data-landing-style="true"] {
        border-radius: 2rem;
        background-color: #ffffff;
        height: 10rem;
      }

      input[type="text"],
      textarea {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid ghostwhite;
        border-radius: 0.5rem;
        font-size: 1rem;
        font-family: inherit;
        transition: border-color 0.1s;
      }

      textarea {
        min-height: 128px;
        height: auto;
        resize: none;
        background: white;
        border-radius: 0;
        overflow: hidden;
      }

      input:focus,
      textarea:focus {
        outline: none;
        border-color: #3b82f6;
      }

      input[type="number"] {
        width: 100%;
        padding: 0.5rem 0.75rem;
        border: 1px solid transparent;
        border-radius: 0.375rem;
        font-size: 1rem;
        background: gainsboro;
        cursor: not-allowed;
      }

      button {
        padding: 0.5rem 1rem;
        border: none;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.1s;
      }

      .btn-primary {
        color: black;
        background-color: none;
        border-radius: 0.5rem;
        border: 1px solid gainsboro;
        font-family: serif;
      }

      .btn-primary:hover:not(:disabled) {
        background: gainsboro !important;
        transition: all 0.1s;
        border: 1px solid gainsboro;
      }

      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: white;
        border: 1px solid #d1d5db;
        color: black;
      }

      .btn-secondary:hover {
        background: #f9fafb;
      }

      .btn-tertiary {
        color: black;
        background: none;
        border: none;
        padding: 0px;
        color: blue;
      }

      .btn-premium {
        background: white;
        color: #667eea;
        font-weight: 600;
        font-size: 1rem;
        padding: 1rem 1.5rem;
      }

      .btn-premium:hover {
        transform: translateY(-2px);
      }

      .btn-large {
        width: 100%;
        padding: 0.75rem;
        font-size: 1rem;
      }

      .btn-large:hover:not(:disabled) {
        background: coral !important;
        color: white;
        border: 1px solid white;
        transition: all 0.2s;
        font-family: serif;
      }

      .query-section {
        background: transparent;
      }

      .query-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: gray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-decoration: underline;
      }

      .terms-section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .terms-container {
        align-items: flex-start;
        display: flex;
        flex-wrap: wrap;
      }

      .term-badge {
        display: inline-flex;
        align-items: center;
        color: black;
        border-radius: 9999px;
        font-size: 1rem;
        position: relative;
        cursor: pointer;
        transition: all 0.1s;
        user-select: none;
        opacity: 1;
        transform: translateY(0);
      }

      .term-badge.term-enter {
        opacity: 0;
        transform: translateY(8px);
        animation: termFadeIn 0.35s ease forwards;
        animation-delay: var(--term-delay, 0s);
      }

      @keyframes termFadeIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .term-badge:hover {
        padding-left: 1.75rem;
      }

      .popover .hidden {
        display: none;
      }

      .term-remove {
        position: absolute;
        left: 0.35rem;
        width: 1.25rem;
        height: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #6b7280;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.1s;
        font-size: 1.1rem;
        line-height: 1;
      }

      .term-badge:hover .term-remove {
        opacity: 1;
      }

      .term-remove:hover {
        color: #ef4444;
      }

      .popover {
        position: absolute;
        z-index: 1000;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1rem;
        min-width: 250px;
        max-width: 350px;
        display: none;
      }

      .popover.show {
        display: block;
      }

      .popover-title {
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 0.5rem;
      }

      .popover-subtitle {
        font-size: 0.75rem;
        color: #6b7280;
        margin-bottom: 0.75rem;
      }

      .related-terms {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .related-badge {
        padding: 0.25rem 0.6rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 9999px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.1s;
        position: relative;
        padding-left: 1.5rem;
      }

      .related-badge:hover {
        background: #f0f9ff;
        border-color: #3b82f6;
      }

      .related-badge::before {
        content: "+";
        position: absolute;
        left: 0.4rem;
        font-weight: bold;
        color: #3b82f6;
      }

      .operator {
        padding-top: 2px;
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        letter-spacing: 0.05em;
        font-family: "Courier New", monospace;
      }

      .operator-and {
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-align: center;
      }

      .loading-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.75rem;
        color: lightgray;
      }
      .progress-container {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }
      .progress-track {
        position: relative;
        height: 0.5rem;
        border-radius: 9999px;
        background: #e5e7eb;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #3b82f6, #2563eb);
        border-radius: inherit;
        transition: width 0.2s ease-out;
      }
      .progress-track-generating {
        height: 0.4rem;
        background: white;
      }
      .progress-bar-generating {
        width: 100%;
        height: 100%;
        background: transparent;
        position: relative;
        border-radius: inherit;
        overflow: hidden;
      }
      .progress-bar-generating::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(98deg, white, lightgray, white);
        transform: translateX(-100%);
        animation: progress-bar-generating 1s ease-in-out infinite;
      }
      @keyframes progress-bar-generating {
        0% {
          transform: translateX(-100%);
        }
        65% {
          transform: translateX(0%);
        }
        100% {
          transform: translateX(100%);
        }
      }
      .progress-message {
        font-size: 0.75rem;
        color: gray;
        text-align: center;
      }

      .spinner-small {
        width: 1rem;
        height: 1rem;
        border: 2px solid lightgray;
        border-top-color: darkgray;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      .results-container {
        margin-top: 1.5rem;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 1.5rem;
      }

      .result-item {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1.25rem;
        margin-bottom: 1rem;
      }

      .result-item:last-child {
        margin-bottom: 0;
      }

      .result-title {
        font-weight: 600;
        color: #111827;
      }

      .result-abstract {
        font-size: 1rem;
        color: #6b7280;
        margin-bottom: 0.5rem;
      }

      .result-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .result-link {
        color: #3b82f6;
        text-decoration: none;
        font-size: 1rem;
      }

      .result-link:hover {
        text-decoration: underline;
      }

      .loading {
        text-align: center;
        padding: 2rem;
        color: #6b7280;
      }

      .spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        border: 3px solid #e5e7eb;
        border-top-color: #3b82f6;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: gray;
        font-size: 1rem;
        border: 2px dashed #e5e7eb;
        border-radius: 0.5rem;
      }

      .hidden {
        display: none;
      }

      .score-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .score-low {
        background: #dbeafe;
        color: #1e40af;
      }
      .score-medium {
        background: #fef3c7;
        color: #92400e;
      }
      .score-high {
        background: #fecaca;
        color: #991b1b;
      }

      /* Premium Card Styles */
      .premium-icon {
        font-size: 3rem;
        text-align: center;
        margin-bottom: 1rem;
      }

      .premium-price {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin: 1rem 0;
      }

      .premium-price small {
        font-size: 1rem;
        font-weight: 400;
        opacity: 0.9;
      }

      .premium-features {
        list-style: none;
        margin: 1.5rem 0;
      }

      .premium-features li {
        padding: 0.5rem 0;
        padding-left: 1.5rem;
        position: relative;
      }

      .premium-features li::before {
        content: "âœ“";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #a5f3fc;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-content">
        <div>
          <h1>Prior Art Research Tool</h1>
          <p class="subtitle">
            Secure and Instant Research for Patent Applications
          </p>
        </div>
      </div>
    </header>

    <main>
      <div class="initial-center" id="initialPromptWrapper">
        <div class="card">
          <div class="landing-header-text" id="landingHeaderText">
            <h1>Prior Art Research Tool</h1>
            <p class="subtitle">
              Secure and Instant Research for Patent Applications
            </p>
          </div>
          <div id="promptSection">
            <label for="promptInput" id="titleLabel" class="hidden"
              >Title</label
            >
            <div class="input-group" data-landing-style="true">
              <input
                type="text"
                id="promptInput"
                placeholder="Enter invention title"
                style="height: fit-content; border: none"
              />
              <button
                class="btn-primary"
                style="
                  place-self: flex-end;
                  height: 44px;
                  margin-right: 1rem;
                  margin-bottom: 1rem;
                  width: -webkit-fill-available;
                  max-width: fit-content;
                "
                onclick="generateDescription()"
                id="generateBtn"
              >
                Generate
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="grid hidden" id="mainContent">
        <!-- Left: Description Editor -->
        <div class="card" id="descriptionCard">
          <h2 class="card-title">Description</h2>

          <div class="input-section hidden" id="descriptionSection">
            <!-- <label for="userDescription">Description</label> -->
            <div
              class="progress-container hidden"
              id="generatingIndicator"
              aria-hidden="true"
            >
              <div class="progress-track progress-track-generating">
                <div class="progress-bar progress-bar-generating"></div>
              </div>
            </div>
            <div id="descriptionEditor"></div>

            <textarea
              id="userDescription"
              class="hidden"
              placeholder="Enter description or it will be auto-generated"
            ></textarea>
          </div>
        </div>

        <!-- Right Column -->
        <div id="postGenerateColumn" style="padding-left: 4rem" class="hidden">
          <!-- Query Builder -->
          <div class="card">
            <h2 class="card-title">
              <span style="cursor: default">Related Terms</span>
              <span id="extractingIndicator" class="loading-indicator hidden">
                <div class="spinner-small"></div>
                <span style="font-weight: 500; color: darkgray"
                  >extracting key terms...</span
                >
              </span>
            </h2>

            <div id="queryBuilder">
              <div id="emptyState" class="empty-state">
                <p style="cursor: default">Keywords will be generated here</p>
              </div>

              <div
                id="queryPreview"
                class="hidden"
                style="padding: 1.5rem; border: 1px dashed gainsboro"
              >
                <div class="query-section">
                  <div class="query-label">Devices / Technologies</div>
                  <div class="terms-section">
                    <div class="terms-container" id="deviceTechTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addDeviceTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>

                <div id="andOperator" class="operator-and hidden">AND</div>

                <div class="query-section" id="subjectSection">
                  <div class="query-label">Subjects</div>
                  <div class="terms-section">
                    <div class="terms-container" id="subjectTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addSubjectTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <div class="input-section" style="display: none">
              <label for="maxDisplayResults">Max results to display</label>
              <input
                type="number"
                id="maxDisplayResults"
                min="1"
                max="1000"
                value="100"
              />
            </div>
            <button
              class="btn-primary btn-large hidden"
              onclick="startSearch()"
              id="searchButton"
              style="margin-top: 1rem"
            >
              Search
            </button>
            <div id="searchProgress" class="progress-container hidden">
              <div class="progress-track">
                <div id="searchProgressBar" class="progress-bar"></div>
              </div>
              <div id="searchProgressMessage" class="progress-message"></div>
            </div>
            <p
              id="searchStatusMessage"
              class="hidden"
              style="
                text-align: center;
                margin-top: 0.75rem;
                color: #6b7280;
                font-size: 0.875rem;
              "
            ></p>
          </div>

          <!-- Premium Upgrade Card -->
          <!-- <div class="card card-premium">
          <div class="premium-icon">ðŸš€</div>
          <h2 class="card-title" style="color: white; justify-content: center;">
            Unlock Detailed Analysis
          </h2>
          
          <div class="premium-price">
            $19.99
            <small>one-time</small>
          </div>

          <ul class="premium-features">
            <li><strong>AI-Powered Risk Scoring</strong> - Each patent analyzed with similarity scores (0-100)</li>
            <li><strong>Risk Level Classification</strong> - Low/Medium/High/Critical ratings for quick triage</li>
            <li><strong>Expert Reasoning</strong> - AI explains WHY each patent is relevant to your invention</li>
            <li><strong>Unlimited Results</strong> - Search up to 2,000 patents (vs 10 free)</li>
            <li><strong>Detailed CSV Export</strong> - Download comprehensive report with all analysis</li>
            <li><strong>Google Patents Links</strong> - Direct links to full patent documents</li>
            <li><strong>Priority Support</strong> - Get help from our patent search experts</li>
          </ul>

          <button class="btn-premium btn-large" onclick="unlockPremium()">
            ðŸ”“ Unlock Full Analysis - $19.99
          </button>

          <p style="text-align: center; margin-top: 1rem; font-size: 0.75rem; opacity: 0.9;">
            Secure payment via Stripe â€¢ Instant access â€¢ No subscription
          </p>
        </div> -->
        </div>
      </div>
      <button
        class="btn-secondary btn-large hidden"
        onclick="downloadCSV()"
        id="downloadButton"
      >
        Download .csv
      </button>
      <div id="resultsContainer" class="results-container hidden"></div>
    </main>

    <div id="termPopover" class="popover">
      <div id="popoverHoverTitle">
        <div class="popover-title">Related Terms</div>
        <div class="popover-subtitle">Click to add synonyms</div>
      </div>

      <div id="popoverAddSection" class="hidden">
        <div class="popover-title">Add New Term</div>
        <div class="input-group">
          <input
            type="text"
            id="addTermInput"
            placeholder="Type a term..."
            style="padding: 0.5rem"
          />
        </div>
        <div class="popover-subtitle" style="margin-top: 0.5rem">
          Suggestions will appear below. Press Enter to add.
        </div>
      </div>

      <div id="relatedTermsContainer" class="related-terms"></div>
    </div>

    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>

    <script>
      const API_BASE =
        window.location.hostname === "localhost" &&
        (window.location.port === "8080" || window.location.port === "3000")
          ? "http://localhost:8000"
          : "";
      let eventSource = null;
      let extractTimeout = null;
      let currentTerms = {
        deviceTerms: [],
        technologyTerms: [],
        subjectTerms: [],
      };
      let relatedTermsCache = {};
      let currentHoverTerm = null;
      let popoverTimeout = null;
      let lastSearchQuery = "";
      let lastTopK = 100;
      let scoreThreshold = 60;
      let popoverContext = {
        mode: null,
        category: null,
      };
      let totalPatentsDisplay = null;
      let addTermDebounceTimeout = null;
      let progressTotalCandidates = null;
      let progressAnalyzedCount = 0;
      let currentProgressPercent = 0;
      let latestProgressMessage = "";
      let progressHideTimeout = null;
      const addTermButtons = {
        device: document.getElementById("addDeviceTermButton"),
        subject: document.getElementById("addSubjectTermButton"),
      };
      const MIN_EDITOR_HEIGHT = 320;
      const descriptionSection = document.getElementById("descriptionSection");
      const postGenerateColumn = document.getElementById("postGenerateColumn");
      const landingHeaderText = document.getElementById("landingHeaderText");
      const initialPromptWrapper = document.getElementById(
        "initialPromptWrapper"
      );
      const descriptionCard = document.getElementById("descriptionCard");
      const promptSection = document.getElementById("promptSection");
      const landingInputGroup = document.querySelector(
        "[data-landing-style=\"true\"]"
      );
      const titleLabel = document.getElementById("titleLabel");
      const mainContent = document.getElementById("mainContent");
      const header = document.querySelector("header");
      const main = document.querySelector("main");
      let hasUnlockedInterface = false;
      const renderedTermNodes = {
        device: new Map(),
        subject: new Map(),
      };

      Object.entries(addTermButtons).forEach(([category, button]) => {
        if (!button) return;
        button.addEventListener("click", (e) =>
          showAddTermPopover(e.currentTarget, category)
        );
      });

      const descriptionTextarea = document.getElementById("userDescription");
      const descriptionEditor = new toastui.Editor({
        el: document.getElementById("descriptionEditor"),
        height: "420px",
        initialEditType: "wysiwyg",
        previewStyle: "vertical",
        hideModeSwitch: true,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["link", "code", "codeblock"],
        ],
        initialValue: descriptionTextarea ? descriptionTextarea.value : "",
      });
      let isGeneratingDescription = false;

      let adjustHeightFrame = null;
      function adjustEditorHeight() {
        if (adjustHeightFrame) {
          cancelAnimationFrame(adjustHeightFrame);
        }
        adjustHeightFrame = requestAnimationFrame(() => {
          const editorRoot = document.getElementById("descriptionEditor");
          if (!editorRoot) return;
          const defaultUI = editorRoot.querySelector(
            ".toastui-editor-defaultUI"
          );
          if (!defaultUI) return;

          const main = defaultUI.querySelector(".toastui-editor-main");
          if (!main) return;

          defaultUI.style.height = "auto";
          main.style.height = "auto";

          const toolbar = defaultUI.querySelector(".toastui-editor-toolbar");
          const modeSwitch = defaultUI.querySelector(
            ".toastui-editor-mode-switch"
          );
          const toolbarHeight = toolbar ? toolbar.offsetHeight : 0;
          const modeSwitchHeight = modeSwitch ? modeSwitch.offsetHeight : 0;

          const contentHeight = main.scrollHeight;
          const extraPadding = 32;
          const targetHeight = Math.max(
            contentHeight + toolbarHeight + modeSwitchHeight + extraPadding,
            MIN_EDITOR_HEIGHT
          );
          descriptionEditor.setHeight(`${targetHeight}px`);
        });
      }

      if (descriptionTextarea) {
        descriptionTextarea.value = descriptionEditor.getMarkdown();
      }

      descriptionEditor.on("change", () => {
        const markdown = descriptionEditor.getMarkdown();
        if (descriptionTextarea) {
          descriptionTextarea.value = markdown;
        }
        if (isGeneratingDescription) {
          return;
        }
        clearTimeout(extractTimeout);
        extractTimeout = setTimeout(() => {
          extractTerms(markdown);
        }, 2000);
        adjustEditorHeight();
      });

      descriptionEditor.on("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          startSearch();
        }
      });
      adjustEditorHeight();

      // TODO: Replace with your actual Stripe checkout URL
      const STRIPE_CHECKOUT_URL = "https://buy.stripe.com/YOUR_CHECKOUT_LINK";

      function unlockPremium() {
        window.location.href = STRIPE_CHECKOUT_URL;
      }

      function showFullInterface() {
        if (hasUnlockedInterface) return;
        hasUnlockedInterface = true;

        if (header) {
          header.style.display = "block";
          requestAnimationFrame(() => {
            header.classList.add("content-visible");
          });
        }
        if (main) {
          main.classList.add("app-visible");
        }

        const revealInterface = () => {
          if (descriptionCard && promptSection) {
            descriptionCard.insertBefore(
              promptSection,
              descriptionSection || descriptionCard.firstChild
            );
            promptSection.classList.add("prompt-inline");
            promptSection.classList.add("fade-in");
            setTimeout(() => promptSection.classList.remove("fade-in"), 500);
            if (titleLabel) {
              titleLabel.classList.remove("hidden");
            }
          }

          if (mainContent) {
            mainContent.classList.remove("hidden");
            mainContent.classList.add("fade-in");
            setTimeout(() => mainContent.classList.remove("fade-in"), 500);
          }

          if (initialPromptWrapper && initialPromptWrapper.parentNode) {
            if (landingHeaderText && landingHeaderText.parentNode) {
              landingHeaderText.parentNode.removeChild(landingHeaderText);
            }
            initialPromptWrapper.parentNode.removeChild(initialPromptWrapper);
          }

          if (
            landingInputGroup &&
            landingInputGroup.hasAttribute("data-landing-style")
          ) {
            landingInputGroup.removeAttribute("data-landing-style");
          }

          if (descriptionCard) {
            descriptionCard.classList.add("fade-in");
            setTimeout(() => descriptionCard.classList.remove("fade-in"), 500);
          }

          if (descriptionSection) {
            descriptionSection.classList.remove("hidden");
            descriptionSection.classList.add("fade-in");
            setTimeout(
              () => descriptionSection.classList.remove("fade-in"),
              500
            );
          }

          if (postGenerateColumn) {
            postGenerateColumn.classList.remove("hidden");
            postGenerateColumn.classList.add("fade-in");
            setTimeout(
              () => postGenerateColumn.classList.remove("fade-in"),
              500
            );
          }

          adjustEditorHeight();
        };

        if (initialPromptWrapper) {
          initialPromptWrapper.classList.add("fade-out");
          setTimeout(revealInterface, 350);
        } else {
          revealInterface();
        }
      }

      async function fetchTotalPatents() {
        try {
          const res = await fetch(`${API_BASE}/api/stats`);
          if (!res.ok) throw new Error(`Status ${res.status}`);
          const data = await res.json();
          const total = data?.totalPatents;
          if (typeof total === "number" && Number.isFinite(total)) {
            totalPatentsDisplay = total.toLocaleString();
          } else if (typeof total === "string" && total.trim() !== "") {
            const parsed = Number.parseInt(total.replace(/,/g, ""), 10);
            if (!Number.isNaN(parsed)) {
              totalPatentsDisplay = parsed.toLocaleString();
            }
          }
        } catch (err) {
          console.warn("Failed to fetch total patent count:", err);
          totalPatentsDisplay = null;
        }
      }

      async function generateDescription() {
        const prompt = document.getElementById("promptInput").value.trim();
        const btn = document.getElementById("generateBtn");

        if (!prompt) {
          alert("Please enter a brief description of your invention.");
          return;
        }

        showFullInterface();
        btn.disabled = true;
        btn.textContent = "Generating...";
        isGeneratingDescription = true;
        let generatedMarkdown = "";
        descriptionEditor.setMarkdown("", false);
        if (descriptionTextarea) {
          descriptionTextarea.value = "";
        }
        adjustEditorHeight();

        const indicator = document.getElementById("generatingIndicator");
        if (indicator) {
          indicator.classList.remove("hidden");
          indicator.setAttribute("aria-hidden", "false");
        }

        try {
          const response = await fetch(`${API_BASE}/api/generate-description`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
          });

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            generatedMarkdown += decoder.decode(value, { stream: true });
            descriptionEditor.setMarkdown(generatedMarkdown, false);
            if (descriptionTextarea) {
              descriptionTextarea.value = generatedMarkdown;
            }
            adjustEditorHeight();
          }
          generatedMarkdown += decoder.decode();
          descriptionEditor.setMarkdown(generatedMarkdown, false);
          if (descriptionTextarea) {
            descriptionTextarea.value = generatedMarkdown;
          }

          isGeneratingDescription = false;
          extractTerms(generatedMarkdown);
        } catch (err) {
          console.error("Error:", err);
          alert("Failed to generate description");
        } finally {
          isGeneratingDescription = false;
          btn.disabled = false;
          btn.textContent = "Generate";
          if (indicator) {
            indicator.classList.add("hidden");
            indicator.setAttribute("aria-hidden", "true");
          }
        }
      }

      async function extractTerms(text) {
        if (!text || text.trim().length < 20) {
          currentTerms = {
            deviceTerms: [],
            technologyTerms: [],
            subjectTerms: [],
          };
          updateQueryPreview();
          return;
        }

        document
          .getElementById("extractingIndicator")
          .classList.remove("hidden");

        try {
          const response = await fetch(`${API_BASE}/api/extract-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ documentText: text }),
          });

          if (response.ok) {
            currentTerms = await response.json();
            updateQueryPreview();
            preloadRelatedTerms();
          }
        } catch (err) {
          console.error("Error:", err);
        } finally {
          document
            .getElementById("extractingIndicator")
            .classList.add("hidden");
        }
      }

      async function preloadRelatedTerms() {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];

        const termsToFetch = allTerms.filter((t) => !relatedTermsCache[t]);
        if (termsToFetch.length === 0) return;

        try {
          const response = await fetch(`${API_BASE}/api/get-related-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: termsToFetch }),
          });

          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn("Failed to fetch related terms:", err);
        }
      }

      function formatProgressMessage(message) {
        if (!message) return "";
        return message.replace(/^\[[^\]]+\]\s*/, "").trim();
      }

      function setSearchProgress(percent, message) {
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;

        if (Number.isFinite(percent)) {
          currentProgressPercent = Math.max(
            0,
            Math.min(100, Math.round(percent))
          );
        }

        if (message) {
          latestProgressMessage = formatProgressMessage(message);
        }

        bar.style.width = `${currentProgressPercent}%`;
        text.textContent = latestProgressMessage;
        container.classList.remove("hidden");
      }

      function resetSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        progressTotalCandidates = null;
        progressAnalyzedCount = 0;
        currentProgressPercent = 0;
        latestProgressMessage = "Starting search...";
        setSearchProgress(5, latestProgressMessage);
      }

      function hideSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;
        currentProgressPercent = 0;
        latestProgressMessage = "";
        bar.style.width = "0%";
        text.textContent = "";
        container.classList.add("hidden");
      }

      function updateSearchProgressFromLog(message) {
        if (!message) return;
        const cleanMessage = formatProgressMessage(message);
        let percent = null;

        if (/starting search/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 5);
        } else if (/finding candidate/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 12);
        } else if (/found\s+(\d+)\s+candidates?/i.test(cleanMessage)) {
          const match = cleanMessage.match(/found\s+(\d+)\s+candidates?/i);
          if (match) {
            progressTotalCandidates = parseInt(match[1], 10) || null;
            progressAnalyzedCount = 0;
          }
          percent = Math.max(currentProgressPercent, 20);
        } else if (/processed\s+(\d+)\s*\/\s*(\d+)/i.test(cleanMessage)) {
          const match = cleanMessage.match(/processed\s+(\d+)\s*\/\s*(\d+)/i);
          if (match) {
            progressAnalyzedCount = parseInt(match[1], 10) || 0;
            const total = parseInt(match[2], 10) || progressTotalCandidates;
            if (total) {
              progressTotalCandidates = total;
              const ratio = Math.max(
                0,
                Math.min(1, progressAnalyzedCount / total)
              );
              percent = Math.max(currentProgressPercent, 20 + ratio * 75);
            }
          }
        } else if (/finished analysis/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 95);
        }

        setSearchProgress(percent, cleanMessage);
      }

      function handleSearchComplete(data) {
        let message = "Search complete";
        if (data && typeof data.analyzed === "number") {
          progressAnalyzedCount = data.analyzed;
        }
        if (data && typeof data.results === "number") {
          message = `${message} - ${data.results} result${
            data.results === 1 ? "" : "s"
          }`;
        }
        if (progressTotalCandidates && progressAnalyzedCount) {
          message = `${message} (${progressAnalyzedCount} analyzed)`;
        }

        setSearchProgress(100, message);
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
        }
        progressHideTimeout = setTimeout(() => {
          hideSearchProgress();
          progressHideTimeout = null;
        }, 1200);
      }

      function updateQueryPreview() {
        const hasTerms =
          currentTerms.deviceTerms.length > 0 ||
          currentTerms.technologyTerms.length > 0 ||
          currentTerms.subjectTerms.length > 0;

        document
          .getElementById("emptyState")
          .classList.toggle("hidden", hasTerms);
        document
          .getElementById("queryPreview")
          .classList.toggle("hidden", !hasTerms);

        const searchButton = document.getElementById("searchButton");
        if (searchButton) {
          searchButton.classList.toggle("hidden", !hasTerms);
        }

        const combinedTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
        ];
        const sortedDeviceTerms = combinedTerms
          .slice()
          .sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: "base" })
          );
        const sortedSubjectTerms = currentTerms.subjectTerms
          .slice()
          .sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: "base" })
          );

        renderTerms("deviceTechTerms", sortedDeviceTerms, "device");
        renderTerms("subjectTerms", sortedSubjectTerms, "subject");

        document
          .getElementById("andOperator")
          .classList.toggle(
            "hidden",
            combinedTerms.length === 0 || currentTerms.subjectTerms.length === 0
          );
      }

      function createTermBadge(term) {
        const badge = document.createElement("span");
        badge.className = "term-badge term-enter";
        badge.dataset.term = term;

        const removeButton = document.createElement("span");
        removeButton.className = "term-remove";
        removeButton.textContent = "Ã—";
        removeButton.addEventListener("click", (event) => {
          event.stopPropagation();
          removeTerm(term);
        });

        badge.appendChild(removeButton);
        badge.appendChild(document.createTextNode(term));

        badge.addEventListener("mouseenter", (e) =>
          showHoverPopover(e.currentTarget, term)
        );
        badge.addEventListener("mouseleave", hidePopover);
        badge.addEventListener("animationend", () =>
          badge.classList.remove("term-enter")
        );

        return badge;
      }

      function renderTerms(containerId, terms, category) {
        const container = document.getElementById(containerId);
        if (!container) return;
        const registry =
          renderedTermNodes[category] ||
          (renderedTermNodes[category] = new Map());

        if (!Array.isArray(terms) || terms.length === 0) {
          container.textContent = "";
          registry.clear();
          return;
        }

        const seen = new Set();
        const fragment = document.createDocumentFragment();

        terms.forEach((term, index) => {
          let badge = registry.get(term);
          if (!badge) {
            badge = createTermBadge(term);
            registry.set(term, badge);
            badge.style.setProperty("--term-delay", `${index * 0.08}s`);
          } else {
            badge.classList.remove("term-enter");
            badge.style.removeProperty("--term-delay");
          }
          seen.add(term);
          fragment.appendChild(badge);
          if (index < terms.length - 1) {
            fragment.appendChild(document.createTextNode(",\u00A0"));
          }
        });

        Array.from(registry.keys()).forEach((term) => {
          if (!seen.has(term)) {
            registry.delete(term);
          }
        });

        container.textContent = "";
        container.appendChild(fragment);

        const addButton = addTermButtons[category];
        if (addButton) {
          addButton.classList.remove("hidden");
        }
      }

      function positionPopover(targetElement) {
        const popover = document.getElementById("termPopover");
        if (!targetElement || !popover) return;

        const rect = targetElement.getBoundingClientRect();
        const scrollX = window.scrollX;
        const scrollY = window.scrollY;

        const top = rect.bottom + scrollY + 5;
        const left = rect.left + scrollX;

        popover.style.left = `${left}px`;
        popover.style.top = `${top}px`;
      }

      function showAddTermPopover(buttonElement, category) {
        clearTimeout(popoverTimeout);
        popoverContext = { mode: "add", category: category };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const input = document.getElementById("addTermInput");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.add("hidden");
        addSection.classList.remove("hidden");
        relatedContainer.innerHTML = "";
        input.value = "";

        positionPopover(buttonElement);

        popover.classList.add("show");
        input.focus();

        input.oninput = () => {
          clearTimeout(addTermDebounceTimeout);
          addTermDebounceTimeout = setTimeout(() => {
            const term = input.value.trim();
            if (term) {
              fetchAndDisplayRelated(term, relatedContainer);
            } else {
              relatedContainer.innerHTML = "";
            }
          }, 500);
        };

        // This is the improved part
        input.onkeydown = (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const term = input.value.trim();
            if (term) {
              addRelatedTerm(term);
              hidePopover(); // Close the popover on success
            }
          }
        };

        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      async function fetchAndDisplayRelated(term, container) {
        container.innerHTML =
          '<span style="font-size: 0.75rem; color: #9ca3af;">Loadingâ€¦</span>';

        if (!relatedTermsCache[term]) {
          await fetchRelatedForSingleTerm(term);
        }

        const related = relatedTermsCache[term] || [];
        container.innerHTML = "";

        if (related.length === 0) {
          container.innerHTML =
            '<span style="font-size: 0.75rem; color: #9ca3af;">No suggestions found.</span>';
        } else {
          related.forEach((relTerm) => {
            const badge = document.createElement("span");
            badge.className = "related-badge";
            badge.textContent = relTerm;
            badge.onclick = () => addRelatedTerm(relTerm);
            container.appendChild(badge);
          });
        }
      }

      function showHoverPopover(badgeElement, term) {
        clearTimeout(popoverTimeout);
        currentHoverTerm = term;
        popoverContext = { mode: "hover" };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.remove("hidden");
        addSection.classList.add("hidden");

        positionPopover(badgeElement);

        fetchAndDisplayRelated(term, relatedContainer);

        popover.classList.add("show");
        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      function hidePopover() {
        popoverTimeout = setTimeout(() => {
          document.getElementById("termPopover").classList.remove("show");
        }, 200);
      }

      async function fetchRelatedForSingleTerm(term) {
        if (relatedTermsCache[term]) return;
        try {
          const response = await fetch(`${API_BASE}/api/get-related-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: [term] }),
          });
          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn(`Failed to fetch related terms for ${term}:`, err);
        }
      }

      function addRelatedTerm(term) {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];
        if (allTerms.includes(term)) {
          return;
        }

        if (popoverContext.mode === "add") {
          if (popoverContext.category === "subject") {
            currentTerms.subjectTerms.push(term);
          } else if (popoverContext.category === "device") {
            currentTerms.deviceTerms.push(term);
          } else {
            console.error(
              "addRelatedTerm called in 'add' mode with unknown category:",
              popoverContext.category
            );
            return;
          }
        } else if (popoverContext.mode === "hover" && currentHoverTerm) {
          if (
            currentTerms.deviceTerms.includes(currentHoverTerm) ||
            currentTerms.technologyTerms.includes(currentHoverTerm)
          ) {
            currentTerms.deviceTerms.push(term);
          } else if (currentTerms.subjectTerms.includes(currentHoverTerm)) {
            currentTerms.subjectTerms.push(term);
          }
        } else {
          console.error(
            "addRelatedTerm called in an unknown or invalid state:",
            popoverContext
          );
          return;
        }

        updateQueryPreview();

        if (popoverContext.mode === "hover") {
          hidePopover();
        }
      }

      function removeTerm(term) {
        currentTerms.deviceTerms = currentTerms.deviceTerms.filter(
          (t) => t !== term
        );
        currentTerms.technologyTerms = currentTerms.technologyTerms.filter(
          (t) => t !== term
        );
        currentTerms.subjectTerms = currentTerms.subjectTerms.filter(
          (t) => t !== term
        );
        updateQueryPreview();
      }

      function cleanTextForSearch(text) {
        return text
          .replace(/^#+\s+/gm, "")
          .replace(/\*\*/g, "")
          .replace(/\*/g, "")
          .replace(/__/g, "")
          .replace(/_/g, "")
          .replace(/^\d+\.\s+/gm, "")
          .replace(/^[-â€¢]\s+/gm, "")
          .replace(/\n\n+/g, " ")
          .replace(/\n/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function restoreSearchButton(button) {
        if (!button) return;
        button.disabled = false;
        button.innerHTML = "Search";
        button.style.display = "";
        button.style.alignItems = "";
        button.style.justifyContent = "";
        button.style.gap = "";
      }

      async function startSearch() {
        const maxDisplayResultsInput =
          document.getElementById("maxDisplayResults");
        if (!maxDisplayResultsInput) {
          alert("Error: Could not find the 'topK' input element.");
          return;
        }
        const maxDisplayResults = parseInt(maxDisplayResultsInput.value, 10);

        const resultsContainer = document.getElementById("resultsContainer");
        const searchButton = document.getElementById("searchButton");
        const downloadButton = document.getElementById("downloadButton");
        const searchStatusMessage = document.getElementById(
          "searchStatusMessage"
        );

        if (
          !resultsContainer ||
          !searchButton ||
          !downloadButton ||
          !searchStatusMessage
        ) {
          console.error("Missing required elements");
          alert(
            "A critical UI element is missing. Please check the console for details."
          );
          return;
        }

        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }

        // 1. Reset status message from previous search
        searchStatusMessage.classList.add("hidden");
        searchStatusMessage.textContent = "";

        // 2. Update button to show spinner and new text
        searchButton.disabled = true;
        searchButton.innerHTML = `
    <div class="spinner-small"></div>
    <span>Loading...</span>
  `;
        // Add flex styles to center the content
        searchButton.style.display = "flex";
        searchButton.style.alignItems = "center";
        searchButton.style.justifyContent = "center";
        searchButton.style.gap = "0.5rem";

        let searchQuery = "";
        const { deviceTerms, technologyTerms, subjectTerms } = currentTerms;
        const hasExtractedTerms =
          deviceTerms.length > 0 ||
          technologyTerms.length > 0 ||
          subjectTerms.length > 0;

        if (hasExtractedTerms) {
          const queryParts = [];
          const combinedTech = [...deviceTerms, ...technologyTerms];
          if (combinedTech.length > 0) {
            queryParts.push(
              `A patent describing a device or technology such as: ${combinedTech.join(
                " or "
              )}.`
            );
          }
          if (subjectTerms.length > 0) {
            queryParts.push(
              `Applied in the subject matter or field of: ${subjectTerms.join(
                " or "
              )}.`
            );
          }
          searchQuery = queryParts.join(" ");
        } else {
          const description = descriptionEditor.getMarkdown().trim();
          if (!description) {
            alert("You must generate terms from invention title first.");
            restoreSearchButton(searchButton);
            return;
          }
          searchQuery = cleanTextForSearch(description);
        }

        if (!searchQuery) {
          alert(
            "Could not build a search query. Please check your description."
          );
          restoreSearchButton(searchButton);
          return;
        }

        console.log("Final Search Query:", searchQuery);
        lastSearchQuery = searchQuery;
        lastTopK = maxDisplayResults;

        downloadButton.classList.add("hidden");
        resultsContainer.classList.remove("hidden");
        resultsContainer.innerHTML =
          '<div class="loading"><div class="spinner"></div><p>Searching patents...</p></div>';
        resetSearchProgress();

        let resultCount = 0;
        let hasClearedPlaceholder = false;
        let hasCompleted = false;

        const params = new URLSearchParams({
          userDescription: searchQuery,
          maxDisplayResults: String(maxDisplayResults),
        });

        const searchUrl = `${API_BASE}/api/search?${params.toString()}`;
        eventSource = new EventSource(searchUrl);

        eventSource.addEventListener("log", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            updateSearchProgressFromLog(data.message || "");
          } catch (err) {
            console.warn("Failed to parse log event", err);
          }
        });

        eventSource.addEventListener("result", (event) => {
          try {
            const data = JSON.parse(event.data || "{}");
            const resultPayload = data.result;
            if (
              !resultPayload ||
              resultPayload.score === null ||
              resultPayload.score === undefined ||
              resultPayload.score < scoreThreshold
            ) {
              return;
            }

            if (!hasClearedPlaceholder) {
              resultsContainer.innerHTML = "";
              hasClearedPlaceholder = true;
            }

            if (addResult(resultPayload)) {
              resultCount++;
              searchStatusMessage.classList.add("hidden");
            }
          } catch (err) {
            console.warn("Failed to process result event", err);
          }
        });

        eventSource.addEventListener("complete", (event) => {
          if (hasCompleted) return;
          hasCompleted = true;

          let data = null;
          try {
            data = JSON.parse(event.data || "{}");
            handleSearchComplete(data);
          } catch (err) {
            console.warn("Failed to parse complete event", err);
            hideSearchProgress();
          }

          restoreSearchButton(searchButton);

          if (resultCount > 0) {
            if (data && typeof data.score_threshold === "number") {
              scoreThreshold = data.score_threshold;
            }
            const highConfidenceCount =
              data && typeof data.high_confidence === "number"
                ? data.high_confidence
                : resultCount;
            const totalCandidates =
              data && typeof data.total_candidates === "number"
                ? data.total_candidates
                : highConfidenceCount;
            const corpusText = totalPatentsDisplay || "all patents";
            searchStatusMessage.textContent = `Found ${resultCount} highly relevant matches from ${corpusText} patents.`;
            downloadButton.classList.remove("hidden");
          } else {
            searchStatusMessage.textContent = `No results found with a score of ${scoreThreshold} or above.`;
            resultsContainer.innerHTML = `<div class="empty-state">No results found with a score of ${scoreThreshold} or above.</div>`;
          }
          searchStatusMessage.classList.remove("hidden");

          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        });

        eventSource.onerror = (event) => {
          if (hasCompleted) return;
          console.error("Search stream error:", event);
          hideSearchProgress();
          restoreSearchButton(searchButton);
          resultsContainer.innerHTML =
            '<div class="empty-state">An error occurred during the search. Please check the console.</div>';
          searchStatusMessage.textContent = "Search failed. Please try again.";
          searchStatusMessage.classList.remove("hidden");
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
        };
      }

      function addResult(result) {
        // Only add the result if it meets the active score threshold
        const numericScore =
          typeof result.score === "number"
            ? result.score
            : Number.parseFloat(result.score);

        if (
          Number.isNaN(numericScore) ||
          numericScore === null ||
          numericScore === undefined ||
          numericScore < scoreThreshold
        ) {
          return false; // Indicate that the result was not added
        }

        const resultsContainer = document.getElementById("resultsContainer");
        if (!resultsContainer) return false;

        const existingCards =
          resultsContainer.querySelectorAll(".result-item").length;
        if (existingCards >= lastTopK) {
          return false;
        }

        let scoreClass = "score-low";
        if (numericScore >= 95) {
          scoreClass = "score-high";
        } else if (numericScore >= scoreThreshold) {
          scoreClass = "score-medium";
        }

        const displayScore = Number.isInteger(numericScore)
          ? numericScore
          : numericScore.toFixed(2);

        const scoreDisplay =
          numericScore !== null && numericScore !== undefined
            ? `<span class="score-badge ${scoreClass}">${displayScore}</span>`
            : "";

        const resultHTML = `
    <div class="result-item">
      <div class="result-title">
        ${result.title || "Untitled Patent"}
      </div>
      ${scoreDisplay}
      <div class="result-abstract" style="margin-bottom: 0.75rem;">
        ${result.preview || result.abstract || "No abstract available"}
      </div>
      <div class="result-meta" style="margin-bottom: 0.5rem;">
        <span>${result.patentNumber} â€¢ ${result.filingDate}</span>
      </div>
      ${
        result.googlePatentUrl
          ? `<a href="${result.googlePatentUrl}" target="_blank" class="result-link">View Full Patent on Google Patents â†’</a>`
          : ""
      }
    </div>
  `;
        resultsContainer.insertAdjacentHTML("beforeend", resultHTML);
        return true;
      }
      function downloadCSV() {
        const url = `${API_BASE}/export_csv?userDescription=${encodeURIComponent(
          lastSearchQuery
        )}&topK=${lastTopK}`;
        window.open(url, "_blank");
      }

      document
        .getElementById("promptInput")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            generateDescription();
          }
        });

      fetchTotalPatents();
    </script>
  </body>
</html>
