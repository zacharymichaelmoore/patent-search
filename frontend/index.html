<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Find Patents Instantly</title>
    <link
      rel="stylesheet"
      href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        scroll-behavior: smooth;
      }

      body {
        font-family: Georgia;
        background: whitesmoke;
        color: #111827;
        line-height: 1.6;
      }

      header {
        padding: 2rem 5.5rem;
        display: none;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateY(-20px);
        transition: opacity 0.4s ease-in, transform 0.4s ease;
      }

      header.content-visible {
        display: block;
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transform: translateY(0);
      }

      .toastui-editor-defaultUI {
        border-color: transparent;
      }

      .toastui-editor-defaultUI-toolbar {
        justify-content: center;
        background-color: transparent;
        border: none;
        border-radius: 0px;
      }

      .toastui-editor-toolbar-icons {
        border: none !important;
      }

      .toastui-editor-toolbar {
        position: absolute;
        top: 10px;
        z-index: 9999;
        width: 100%;
      }

      .toastui-editor-contents {
        padding: 6.5rem 4rem !important;
        font-size: 1rem !important;
      }

      .header-content {
        max-width: 1400px;
        margin: 0 auto;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .btn-add-term {
        display: inline-flex;
        align-items: center;
        padding: 0.375rem 0.75rem;
        background: transparent;
        color: black;
        border: 1px solid gainsboro;
        border-radius: 0.5rem;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.1s;
        font-family: serif;
      }

      .btn-add-term:hover {
        color: black;
        background-color: gainsboro;
        border: 1px solid gainsboro;
      }

      .queue-status {
        grid-column: 1 / -1;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        background: white;
        border: 1px solid gainsboro;
        color: black;
        border-radius: 0.25rem;
        padding: 0.75rem 1rem;
        font-family: sans-serif;
        font-size: 0.9rem;
        width: 24rem;
        margin-left: auto;
        margin-right: auto;
      }

      .watch-demo-button {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: transparent;
        border: none;
        color: gray;
        font-family: sans-serif;
        font-size: 0.9rem;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
      }

      .play-icon {
        position: relative;
        display: inline-flex;
        width: 24px;
        height: 24px;
        border: 1.5px solid gray;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
      }

      .play-icon::before {
        content: "";
        width: 11px;
        height: 12px;
        background: gray;
        clip-path: polygon(20% 10%, 20% 90%, 90% 50%);
        border-radius: 3px;
        transform: translateX(1px);
      }

      .video-modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.2);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1100;
        padding: 1.5rem;
      }

      .video-modal-backdrop.show {
        display: flex;
      }

      .video-modal {
        background: white;
        border-radius: 0.75rem;
        max-width: 800px;
        width: 100%;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        padding: 1.5rem;
        position: relative;
      }

      .video-modal-close {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        background: transparent;
        border: none;
        font-size: 1.5rem;
        line-height: 1;
        cursor: pointer;
        color: #1f2937;
      }

      .video-modal video {
        width: 100%;
        border-radius: 0.5rem;
        display: block;
      }

      h1 {
        font-size: 3.5rem;
        font-family: auto;
        font-weight: 700;
        color: #111827;
        line-height: 113%;
      }

      h2 {
        font-family: sans-serif;
      }

      .subtitle {
        font-size: 1rem;
        color: gray;
        font-style: italic;
        padding-right: 7px;
      }

      p {
        font-family: serif;
      }

      main {
        padding: 0;
        opacity: 1;
        transform: none;
        transition: opacity 0.4s ease, transform 0.4s ease, padding 0.4s ease;
        position: relative;
        z-index: 0;
      }

      main.app-visible {
        padding: 0 2.5rem 2rem;
      }

      .initial-center {
        display: flex;
        align-items: center;
        justify-content: center;
        padding-top: 4rem;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      .initial-center .card {
        max-width: 540px;
        width: 100%;
      }

      .fade-out {
        opacity: 0 !important;
        transform: translateY(-20px);
        pointer-events: none;
      }

      .fade-in {
        animation: fadeInUp 0.5s ease forwards;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .grid {
        padding: 0 3rem 0;
        display: grid;
        grid-template-columns: 1fr 450px;
      }

      @media (max-width: 1024px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border-radius: 0.25rem;
      }

      .card-premium {
        background: linear-gradient(135deg, purple 0%, #764ba2 100%);
        color: white;
        border: none;
        margin-top: 1.5rem;
      }

      .card-title {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: default;
      }

      .input-section {
        margin-top: 1rem;
      }

      label {
        display: block;
        font-size: 1rem;
        font-weight: 500;
        color: gray;
        margin-bottom: 0.25rem;
      }

      #descriptionEditor {
        margin-top: 1.5rem;
      }

      .landing-header-text {
        text-align: center;
        margin-bottom: 2.5rem;
      }

      .landing-header-text h1 {
        font-family: Georgia, 'Times New Roman', Times, serif;
        font-size: 2.75rem;
        font-weight: 700;
      }

      .landing-header-text .subtitle {
        font-size: 1rem;
        color: gray;
        font-style: italic;
      }

      #promptSection {
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      #promptSection.prompt-inline {
        margin-bottom: 1.5rem;
      }

      .input-group {
        display: flex;
        gap: 0.5rem;
      }

      input:focus::placeholder {
        color: darkgray;
      }

      ::placeholder {
        color: black;
      }

      .input-group[data-landing-style="true"] {
        border-radius: 2rem;
        background-color: #ffffff;
        height: 10rem;
        border: 1px solid gainsboro;
      }

      input[type="text"],
      textarea {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid ghostwhite;
        border-radius: 2rem;
        font-size: 1rem;
        font-family: inherit;
        transition: border-color 0.1s;
      }

      textarea {
        min-height: 128px;
        height: auto;
        resize: none;
        background: white;
        border-radius: 0;
        overflow: hidden;
      }

      input:focus,
      textarea:focus {
        outline: none;
        border-color: purple;
      }

      input[type="number"] {
        width: 100%;
        padding: 0.5rem 0.75rem;
        border: 1px solid transparent;
        border-radius: 0.375rem;
        font-size: 1rem;
        background: gainsboro;
        cursor: not-allowed;
      }

      button {
        padding: 0.5rem 1rem;
        border: none;
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.1s;
      }

      .btn-primary {
        color: black;
        background-color: #242424;
        font-family: serif;
        width: 90px;
        border-radius: 16px;
      }

      .btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .btn-secondary {
        background: white;
        border: 1px solid #d1d5db;
        color: black;
      }

      .btn-secondary:hover {
        background: #f9fafb;
      }

      .btn-tertiary {
        color: black;
        background: none;
        border: none;
        padding: 0px;
        color: purple;
      }

      .btn-premium {
        background: white;
        color: purple;
        font-weight: 600;
        font-size: 1rem;
        padding: 1rem 1.5rem;
      }

      .btn-premium:hover {
        transform: translateY(-2px);
      }

      .btn-large {
        width: 100%;
        padding: 0.75rem;
        font-size: 1rem;
      }

      .query-section {
        background: transparent;
        margin-top: 1rem;
      }

      .query-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: gray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-decoration: underline;
      }

      .terms-section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }

      .terms-container {
        align-items: flex-start;
        display: flex;
        flex-wrap: wrap;
      }

      .term-badge {
        display: inline-flex;
        align-items: center;
        color: black;
        border-radius: 9999px;
        font-size: 1rem;
        position: relative;
        cursor: pointer;
        transition: all 0.1s;
        user-select: none;
        opacity: 1;
        transform: translateY(0);
      }

      .term-badge.term-enter {
        opacity: 0;
        transform: translateY(8px);
        animation: termFadeIn 0.35s ease forwards;
        animation-delay: var(--term-delay, 0s);
      }

      @keyframes termFadeIn {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .term-badge:hover {
        padding-left: 1.75rem;
      }

      .popover .hidden {
        display: none;
      }

      .term-remove {
        position: absolute;
        left: 0.35rem;
        width: 1.25rem;
        height: 1.25rem;
        display: flex;
        align-items: center;
        justify-content: center;
        color: black;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.1s;
        font-size: 1.1rem;
        line-height: 1;
      }

      .term-badge:hover .term-remove {
        opacity: 1;
      }

      .term-remove:hover {
        color: #ef4444;
      }

      .popover {
        position: absolute;
        z-index: 1000;
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1rem;
        min-width: 250px;
        max-width: 350px;
        display: none;
      }

      .popover.show {
        display: block;
      }

      .popover-title {
        font-weight: 600;
        font-size: 1rem;
        margin-bottom: 0.5rem;
      }

      .popover-subtitle {
        font-size: 0.75rem;
        color: black;
        margin-bottom: 0.75rem;
      }

      .related-terms {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .related-badge {
        padding: 0.25rem 0.6rem;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 9999px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.1s;
        position: relative;
      }

      .related-badge:hover {
        background: rgba(198, 2, 198, 0.125);
        border-color: purple;
      }

      .related-badge::before {
        position: absolute;
        font-weight: bold;
      }

      .operator {
        padding-top: 2px;
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        letter-spacing: 0.05em;
        font-family: "Courier New", monospace;
      }

      .operator-and {
        font-size: 0.75rem;
        font-weight: 600;
        color: darkgray;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
        letter-spacing: 0.05em;
        text-align: center;
      }

      .loading-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.75rem;
        color: lightgray;
      }
      .progress-container {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: stretch;
      }
      .progress-track {
        position: relative;
        height: 0.5rem;
        border-radius: 9999px;
        background: #e5e7eb;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, rgb(120, 0, 120), rgb(161, 0, 161));
        border-radius: inherit;
        transition: width 0.2s ease-out;
      }

      .progress-track-generating {
        height: 0.2rem;
        background: rgb(237, 237, 237);
      }

      .progress-bar-generating {
        width: 100%;
        height: 100%;
        background: transparent;
        position: relative;
        border-radius: inherit;
        overflow: hidden;
      }

      .progress-bar-generating::before {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(98deg, white, lightgray, white);
        transform: translateX(-100%);
        animation: progress-bar-generating 0.65s ease-in-out infinite;
      }

      @keyframes progress-bar-generating {
        0% {
          transform: translateX(-100%);
        }
        65% {
          transform: translateX(0%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .progress-message {
        font-size: 0.75rem;
        color: gray;
        text-align: center;
      }

      .spinner-small {
        width: 1rem;
        height: 1rem;
        border: 2px solid lightgray;
        border-top-color: darkgray;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      .results-container {
        margin-top: 1.5rem;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 1.5rem;
      }

      .result-item {
        background: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        padding: 1.25rem;
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
      }

      .result-item:last-child {
        margin-bottom: 0;
      }

      .result-title {
        font-weight: 600;
        color: #222222;
        height: 3rem;
      }

      .result-abstract {
        font-size: 1rem;
        color: black;
        margin-bottom: 0.5rem;
      }

      .result-meta {
        display: flex;
        gap: 1rem;
        font-size: 0.75rem;
        color: #9ca3af;
      }

      .result-link {
        color: purple;
        text-decoration: none;
        font-size: 1rem;
      }

      .result-link:hover {
        text-decoration: underline;
      }

      .loading {
        text-align: center;
        padding: 2rem;
        color: black;
      }

      .spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        border: 3px solid #e5e7eb;
        border-top-color: purple;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .empty-state {
        text-align: center;
        padding: 3rem 1rem;
        color: gray;
        font-size: 1rem;
        border: 2px dashed #e5e7eb;
        border-radius: 0.5rem;
      }

      .hidden {
        display: none;
      }

      .score-badge {
        font-family: monospace;
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 600;
      }

      .score-low {
        background: #dbeafe;
        color: #1e40af;
      }
      .score-medium {
        background: #fef3c7;
        color: #92400e;
      }
      .score-high {
        background: #fecaca;
        color: #991b1b;
      }

      /* Premium Card Styles */
      .premium-icon {
        font-size: 3rem;
        text-align: center;
        margin-bottom: 1rem;
      }

      .premium-price {
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        margin: 1rem 0;
      }

      .premium-price small {
        font-size: 1rem;
        font-weight: 400;
        opacity: 0.9;
      }

      .premium-features {
        list-style: none;
        margin: 1.5rem 0;
      }

      .premium-features li {
        padding: 0.5rem 0;
        padding-left: 1.5rem;
        position: relative;
      }

      .premium-features li::before {
        content: "âœ“";
        position: absolute;
        left: 0;
        font-weight: bold;
        color: #a5f3fc;
      }

      :root {
        --rainbow-1: hsl(270 85% 68%);
        --rainbow-2: hsl(285 78% 66%);
        --rainbow-3: hsl(255 80% 64%);
        --rainbow-4: hsl(300 72% 70%);
        --rainbow-5: hsl(320 75% 68%);
      }

      .rainbow-button {
        position: relative;
        overflow: hidden;
        background: linear-gradient(#ffffff, #e8e8e8) padding-box,
          linear-gradient(
              90deg,
              var(--rainbow-1),
              var(--rainbow-5),
              var(--rainbow-3),
              var(--rainbow-4),
              var(--rainbow-2)
            )
            border-box;
        border: 2px solid transparent;
        background-size: 200%;
        animation: rainbowShift 3s linear infinite;
      }

      .rainbow-button::before {
        content: "";
        position: absolute;
        inset: 80% 20% -40%;
        background: linear-gradient(
          90deg,
          var(--rainbow-1),
          var(--rainbow-5),
          var(--rainbow-3),
          var(--rainbow-4),
          var(--rainbow-2)
        );
        background-size: 200%;
        filter: blur(18px);
        z-index: -1;
        animation: rainbowShift 3s linear infinite;
      }

      @keyframes rainbowShift {
        0% {
          background-position: 0%;
        }
        100% {
          background-position: 200%;
        }
      }

      .landing-nav {
        position: sticky;
        top: 0;
        z-index: 20;
        width: 100%;
        padding: 0.5rem 1.5rem;
        background: rgb(245 245 245 / 83%);
        backdrop-filter: blur(18px);
      }

      .landing-nav__inner {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1.5rem;
        max-width: 1400px;
        margin: 0 auto;
      }

      .landing-nav__left {
        display: flex;
        align-items: center;
        gap: 1.75rem;
      }

      .landing-nav__logo {
        width: 110px;
        height: auto;
      }

      .landing-nav__links {
        display: flex;
        gap: 1.25rem;
        margin-top: 0.25rem;
      }

      .landing-nav__links a {
        font-family: Georgia;
        font-size: 0.85rem;
        color: #333333;
        text-decoration: none;
        transition: color 0.2s ease;
        padding-top: 4px;
      }

      .landing-nav__links a:hover {
        color: #4338ca;
      }

      .landing-nav__count {
        margin-top: 8px;
        font-family: monospace;
        font-size: 0.77rem;
        color: #333333;
        padding: 0.6rem 1.25rem;
        border-radius: 8px;
        backdrop-filter: blur(10px);
        white-space: nowrap;
        align-self: center;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 214px;
        min-height: 38px;
        position: relative;
        overflow: hidden;
      }

      .landing-nav__count.loading {
        color: transparent;
      }

      .landing-nav__count.loading::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        background: linear-gradient(
          120deg,
          rgba(229, 231, 235, 0.8) 0%,
          rgba(245, 247, 250, 1) 40%,
          rgba(229, 231, 235, 0.8) 80%
        );
        animation: loaderSweep 1.3s ease-in-out infinite;
      }

      .landing-nav__count-content {
        opacity: 0;
        transition: opacity 0.35s ease;
        position: relative;
        z-index: 1;
        color: #111827;
      }

      .landing-nav__count-content.is-visible {
        opacity: 1;
      }

      @keyframes loaderSweep {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      .discover-section {
        max-width: 1400px;
        border: 1px solid #e9e9e9;
        border-radius: 2rem;
        padding: 2rem 40px;
        margin: 2rem;
        transition: opacity 0.4s ease, transform 0.4s ease;
      }

      .discover-header {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        margin-bottom: 1.5rem;
      }

      .discover-title {
        font-size: 2.0rem;
        font-family: Georgia, 'Times New Roman', Times, serif;
        font-weight: 600;
        color: #333333;
      }

      .discover-tabs {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .discover-tab {
        padding: 7px 10px;
        border-radius: 6px;
        background-color: whitesmoke;
        box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.15);
        color: #333333;
        font-weight: 600;
        font-family: sans-serif;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease,
          transform 0.2s ease;
      }

      .discover-tab.is-active {
        background: #E9E9E9;
        color: #333333;
        box-shadow: 0px 0px 0px rgba(0, 0, 0, 0);
      }

      .invention-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 1.75rem;
      }

      @media (max-width: 1200px) {
        .invention-grid {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      @media (max-width: 900px) {
        .invention-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      @media (max-width: 600px) {
        .discover-section {
          padding: 2.25rem 1.75rem;
        }
        .invention-grid {
          grid-template-columns: minmax(0, 1fr);
        }
      }

      .invention-item {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .invention-card {
        position: relative;
        border-radius: 11px;
        border: 1px solid #e9e9e9;
        overflow: hidden;
        aspect-ratio: 1 / 1;
        display: flex;
      }

      .invention-card img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .invention-label {
        font-family: Georgia, 'Times New Roman', Times, serif;
        font-size: 0.97rem;
        color: #333333;
        line-height: 1.4;
        padding: 0.5rem;
      }

      .invention-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.358);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.1s ease-in;
        pointer-events: none;
      }

      .invention-card:hover .invention-overlay {
        opacity: 1;
        pointer-events: auto;
      }

      .invention-action {
        padding: 7px 10px;
        background: #F5F5F5;
        color: #333333;
        border-radius: 6px;
        font-family: sans-serif;
        font-size: 0.90rem;
        font-weight: 600;
        box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.08);
        transition: transform 0.1s ease, box-shadow 0.1s ease;
        pointer-events: auto;
      }

      .invention-empty {
        grid-column: 1 / -1;
        text-align: center;
        padding: 2.5rem 1.5rem;
        border: 1px dashed #d1d5db;
        border-radius: 1.25rem;
        font-family: sans-serif;
        font-size: 1rem;
        color: #6b7280;
        background: rgba(255, 255, 255, 0.65);
      }
    </style>
  </head>
  <body>
    <nav class="landing-nav">
      <div class="landing-nav__inner">
        <div class="landing-nav__left">
          <img
            src="{{ url_for('static', path='patty-logo.svg') }}"
            alt="Patty"
            class="landing-nav__logo"
          />
          <div class="landing-nav__links">
            <a href="/">Search Patents</a>
            <a href="#discover">Discover Inventions</a>
            <a href="#faq">FAQ</a>
          </div>
        </div>
        <div class="landing-nav__count loading" id="indexedCountBadge">
          <span class="landing-nav__count-content" id="indexedCountText">
            Patents Indexed
          </span>
        </div>
      </div>
    </nav>
    <header>
      <div class="header-content">
        <div style="display: none">
          <h1>Prior Art Research Tool</h1>
          <p class="subtitle">
            Secure and Instant Research for Patent Applications
          </p>
        </div>
      </div>
    </header>

    <main>
      <div
        class="initial-center"
        id="landingContentWrapper"
        style="display: flex; flex-direction: column;"
      >
        <div class="card" style="margin-bottom: 2rem; padding-top: 0rem;">
          <div class="landing-header-text" id="landingHeaderText">
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: center;
              "
            >
              <h1>Find patents</h1>
              <img
                src="{{ url_for('static', path='patty-logo.svg') }}"
                width="200px"
                style="padding-bottom: 5px"
              />
            </div>
            <p class="subtitle">
              Securely and instantly find patents and conduct Prior Art
              research.
            </p>
          </div>
          <div
            style="
              display: flex;
              flex-direction: column;
              justify-content: center;
            "
          >
            <div id="promptSection">
              <label for="promptInput" id="titleLabel" class="hidden"
                >Title</label
              >
              <div class="input-group" data-landing-style="true">
                <input
                  type="text"
                  id="promptInput"
                  placeholder="Describe the invention"
                  autofocus
                  style="
                    padding-inline-start: 1.5rem;
                    padding-top: 1rem;
                    height: fit-content;
                    border: none;
                    border-radius: 2rem;
                    margin-top: 0.5rem;
                    margin-left: 0.5rem;
                  "
                  autocomplete="off"
                />
                <button
                  class="btn-primary rainbow-button"
                  style="
                    place-self: flex-end;
                    height: 44px;
                    margin-right: 1rem;
                    margin-bottom: 1rem;
                    width: -webkit-fill-available;
                    max-width: fit-content;
                    font-family: sans-serif;
                    font-size: 0.9rem;
                  "
                  onclick="generateDescription()"
                  id="generateBtn"
                >
                  Search for free
                </button>
              </div>
            </div>
            <div
              style="
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                margin-top: 0.5rem;
              "
            >
              <button
                class="watch-demo-button"
                type="button"
                id="watchDemoButton"
                aria-haspopup="dialog"
              >
                <span class="play-icon" aria-hidden="true"></span>
                <span style="text-decoration: underline"
                  >Watch how it works (1:25)</span
                >
              </button>
            </div>
          </div>
        </div>
      </div>
      <section class="discover-section" id="discover">
        <div class="discover-header">
          <h2 class="discover-title">Discover Inventions</h2>
          <div class="discover-tabs" role="tablist">
            <button
              type="button"
              class="discover-tab is-active"
              data-category="featured"
            >
              Featured
            </button>
            <button
              type="button"
              class="discover-tab"
              data-category="smart-home"
            >
              Smart Home
            </button>
            <button
              type="button"
              class="discover-tab"
              data-category="automotive"
            >
              Automotive
            </button>
            <button
              type="button"
              class="discover-tab"
              data-category="manufacturing"
            >
              Manufacturing
            </button>
          </div>
        </div>
        <div class="invention-grid" id="inventionGrid"></div>
      </section>

      <div class="grid hidden" id="mainContent">
        <div id="queueStatusBanner" class="queue-status hidden">
          <div class="spinner-small" aria-hidden="true"></div>
          <span id="queueStatusText"></span>
        </div>
        <!-- Left: Description Editor -->
        <div class="card" id="descriptionCard" style="margin-bottom: 3rem">
          <h2 class="card-title">Description</h2>
          <p style="color: gray">
            ðŸ”’ 100% Private - The invention and description never leave your
            browser.
          </p>
          <p style="color: gray">
            The description is only used to construct a search query and query
            is not stored anywhere.
          </p>

          <div class="input-section hidden" id="descriptionSection">
            <div
              class="progress-container hidden"
              id="generatingIndicator"
              aria-hidden="true"
            >
              <div class="progress-track progress-track-generating">
                <div class="progress-bar progress-bar-generating"></div>
              </div>
            </div>
            <div id="descriptionEditor"></div>

            <textarea
              id="userDescription"
              class="hidden"
              placeholder="Enter description or it will be auto-generated"
            ></textarea>
          </div>
        </div>

        <!-- Right Column -->
        <div id="postGenerateColumn" style="padding-left: 2rem" class="hidden">
          <!-- Query Builder -->
          <div class="card" style="display: flex; flex-direction: column">
            <h2 class="card-title">
              <span style="cursor: default">Related Terms</span>
              <span
                id="extractingIndicator"
                class="loading-indicator hidden"
                style="padding-right: 1rem"
              >
                <div class="spinner-small"></div>
                <span style="font-weight: 500; color: black"
                  >extracting key terms</span
                >
              </span>
            </h2>

            <div id="queryBuilder">
              <div id="emptyState" class="empty-state">
                <p style="cursor: default">Keywords will be added here</p>
              </div>

              <div id="queryPreview" class="hidden">
                <div class="query-section">
                  <div class="query-label">Devices / Technologies</div>
                  <div class="terms-section">
                    <div class="terms-container" id="deviceTechTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addDeviceTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>
                <div
                  class="query-section"
                  id="subjectSection"
                  style="margin-top: 2rem"
                >
                  <div class="query-label">Subjects</div>
                  <div class="terms-section">
                    <div class="terms-container" id="subjectTerms"></div>
                    <button
                      class="btn-add-term hidden"
                      id="addSubjectTermButton"
                    >
                      + Add
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <div class="input-section" style="display: none">
              <label for="maxDisplayResults">Max results to display</label>
              <input
                type="number"
                id="maxDisplayResults"
                min="1"
                max="1000"
                value="100"
              />
            </div>
            <button
              class="btn-primary btn-large hidden rainbow-button"
              onclick="startSearch()"
              id="searchButton"
              data-default-label="Find related patents"
              style="
                margin-top: 1.5rem;
                align-self: start;
                width: 180px;
                font-family: sans-serif;
                font-size: 0.9rem;
              "
            >
              Find related patents
            </button>
            <div id="searchProgress" class="progress-container hidden">
              <div class="progress-track">
                <div id="searchProgressBar" class="progress-bar"></div>
              </div>
              <div id="searchProgressMessage" class="progress-message"></div>
            </div>
            <p
              id="searchStatusMessage"
              class="hidden"
              style="
                text-align: center;
                margin-top: 2rem;
                color: black;
                font-size: 0.875rem;
                padding: 0.5rem;
                background-color: white;
                border-radius: 0.25rem;
              "
            ></p>
            <button
              id="showResultsButton"
              class="btn-primary btn-large hidden rainbow-button"
              type="button"
              style="
                margin-top: 1.5rem;
                align-self: start;
                width: 180px;
                font-family: sans-serif;
                font-size: 0.9rem;
              "
              onclick="showResultsView()"
            >
              Show results
            </button>
          </div>
        </div>
      </div>
      <button
        class="btn-secondary btn-large hidden"
        onclick="downloadCSV()"
        id="downloadButton"
      >
        Download .csv
      </button>
      <div id="resultsContainer" class="results-container hidden"></div>
    </main>

    <div
      id="videoModal"
      class="video-modal-backdrop"
      role="dialog"
      aria-modal="true"
      aria-labelledby="videoModalTitle"
      aria-hidden="true"
    >
      <div class="video-modal">
        <button
          type="button"
          class="video-modal-close"
          aria-label="Close video"
          id="closeVideoModalButton"
        >
          &times;
        </button>
        <h3
          id="videoModalTitle"
          style="
            font-family: sans-serif;
            font-size: 1.125rem;
            margin-bottom: 0.75rem;
            color: #111827;
          "
        >
          Watch how it works
        </h3>
        <video id="demoVideo" controls preload="metadata">
          <source
            src="{{ url_for('static', path='patty-demo.mp4') }}"
            type="video/mp4"
          />
          Your browser does not support the video tag.
        </video>
      </div>
    </div>

    <div id="termPopover" class="popover">
      <div id="popoverHoverTitle">
        <div class="popover-title">Related Terms</div>
      </div>

      <div id="popoverAddSection" class="hidden">
        <div class="popover-title">Add New Term</div>
        <div class="input-group" style="box-shadow: none">
          <input
            type="text"
            id="addTermInput"
            placeholder="Type a term..."
            style="padding: 0.5rem; border-radius: 0px"
          />
        </div>
        <div class="popover-subtitle" style="margin-top: 0.5rem">
          Suggestions will appear below. Press Enter to add.
        </div>
      </div>

      <div id="relatedTermsContainer" class="related-terms"></div>
    </div>

    <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>

    <script>
      const API_BASE =
        window.location.hostname === "localhost" &&
        (window.location.port === "8080" || window.location.port === "3000")
          ? "http://localhost:8000"
          : "";
      let eventSource = null;
      let extractTimeout = null;
      let currentTerms = {
        deviceTerms: [],
        technologyTerms: [],
        subjectTerms: [],
      };
      let relatedTermsCache = {};
      let currentHoverTerm = null;
      let popoverTimeout = null;
      let lastSearchQuery = "";
      let lastTopK = 100;
      let hasUnlockedInterface = false;
      let descriptionAbortController = null;

      const watchDemoButton = document.getElementById("watchDemoButton");
      const videoModal = document.getElementById("videoModal");
      const demoVideo = document.getElementById("demoVideo");
      const closeVideoModalButton = document.getElementById(
        "closeVideoModalButton"
      );

      function openVideoModal() {
        if (!videoModal || !demoVideo) return;
        videoModal.classList.add("show");
        videoModal.setAttribute("aria-hidden", "false");
        demoVideo.currentTime = 0;
        const playPromise = demoVideo.play();
        if (playPromise && typeof playPromise.catch === "function") {
          playPromise.catch(() => {
            /* Ignore autoplay rejection; user can press play manually */
          });
        }
        if (closeVideoModalButton) {
          closeVideoModalButton.focus();
        }
      }

      function closeVideoModal() {
        if (!videoModal || !demoVideo) return;
        demoVideo.pause();
        videoModal.classList.remove("show");
        videoModal.setAttribute("aria-hidden", "true");
        if (watchDemoButton) {
          watchDemoButton.focus();
        }
      }

      if (watchDemoButton) {
        watchDemoButton.addEventListener("click", openVideoModal);
      }

      if (closeVideoModalButton) {
        closeVideoModalButton.addEventListener("click", closeVideoModal);
      }

      if (videoModal) {
        videoModal.addEventListener("click", (event) => {
          if (event.target === videoModal) {
            closeVideoModal();
          }
        });
      }

      document.addEventListener("keydown", (event) => {
        if (
          event.key === "Escape" &&
          videoModal &&
          videoModal.classList.contains("show")
        ) {
          closeVideoModal();
        }
      });
      let scoreThreshold = 60;
      let popoverContext = {
        mode: null,
        category: null,
      };
      let totalPatentsDisplay = null;
      let addTermDebounceTimeout = null;
      let progressTotalCandidates = null;
      let progressAnalyzedCount = 0;
      let currentProgressPercent = 0;
      let latestProgressMessage = "";
      let progressHideTimeout = null;
      const addTermButtons = {
        device: document.getElementById("addDeviceTermButton"),
        subject: document.getElementById("addSubjectTermButton"),
      };
      function hideTermAddButtons() {
        Object.values(addTermButtons).forEach((button) => {
          if (!button) return;
          button.classList.add("hidden");
        });
      }
      const MIN_EDITOR_HEIGHT = 320;
      const descriptionSection = document.getElementById("descriptionSection");
      const postGenerateColumn = document.getElementById("postGenerateColumn");
      const landingContentWrapper = document.getElementById(
        "landingContentWrapper"
      );
      const discoverSection = document.getElementById("discover");
      const descriptionCard = document.getElementById("descriptionCard");
      const mainContent = document.getElementById("mainContent");
      const header = document.querySelector("header");
      const main = document.querySelector("main");
      const indexedCountBadge = document.getElementById("indexedCountBadge");
      const indexedCountText = document.getElementById("indexedCountText");
      const INDEX_COUNT_OFFSET = 6;
      let indexedCountAnimationFrame = null;
      if (indexedCountBadge) {
        indexedCountBadge.dataset.countValue = "0";
        indexedCountBadge.classList.add("loading");
      }
      const renderedTermNodes = {
        device: new Map(),
        subject: new Map(),
      };
      const SEARCH_BUTTON_DEFAULT_LABEL = "Find related patents";
      const searchButtonEl = document.getElementById("searchButton");
      if (searchButtonEl) {
        const initialLabel = searchButtonEl.textContent.trim();
        searchButtonEl.dataset.defaultLabel =
          searchButtonEl.dataset.defaultLabel ||
          (initialLabel ? initialLabel : SEARCH_BUTTON_DEFAULT_LABEL);
        if (!initialLabel) {
          searchButtonEl.textContent = SEARCH_BUTTON_DEFAULT_LABEL;
        }
      }
      const resultsContainerEl = document.getElementById("resultsContainer");
      const downloadButtonEl = document.getElementById("downloadButton");
      const showResultsButton = document.getElementById("showResultsButton");
      const showResultsButtonHome = showResultsButton
        ? showResultsButton.parentElement
        : null;
      if (downloadButtonEl) {
        downloadButtonEl.dataset.available = "false";
      }
      if (showResultsButton) {
        showResultsButton.dataset.available = "false";
      }

      const landingNav = document.querySelector(".landing-nav");
      const navAnchorLinks = document.querySelectorAll(
        ".landing-nav__links a[href^='#']"
      );

      function cancelActiveGeneration() {
        if (descriptionAbortController) {
          descriptionAbortController.abort();
          descriptionAbortController = null;
        }
        isGeneratingDescription = false;
        if (extractTimeout) {
          clearTimeout(extractTimeout);
          extractTimeout = null;
        }
        const generateBtn = document.getElementById("generateBtn");
        if (generateBtn) {
          generateBtn.disabled = false;
          generateBtn.textContent = "Search for free";
        }
        const generatingIndicator = document.getElementById(
          "generatingIndicator"
        );
        if (generatingIndicator) {
          generatingIndicator.classList.add("hidden");
          generatingIndicator.setAttribute("aria-hidden", "true");
        }
        const extractingIndicator = document.getElementById(
          "extractingIndicator"
        );
        if (extractingIndicator) {
          extractingIndicator.classList.add("hidden");
        }
      }

      function cancelActiveSearch() {
        searchCancellationRequested = true;
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        hideQueueStatus();
        hideSearchProgress();
        searchQueueToken = null;

        const searchButton = document.getElementById("searchButton");
        if (searchButton) {
          restoreSearchButton(searchButton, { hideAfterRestore: true });
        }

        if (resultsContainerEl) {
          resultsContainerEl.innerHTML = "";
          resultsContainerEl.classList.add("hidden");
        }
        if (downloadButtonEl) {
          downloadButtonEl.dataset.available = "false";
          downloadButtonEl.classList.add("hidden");
        }
        if (showResultsButton) {
          showResultsButton.dataset.available = "false";
          showResultsButton.textContent = "Show results";
          showResultsButton.classList.add("hidden");
          if (
            showResultsButtonHome &&
            showResultsButton.parentElement !== showResultsButtonHome
          ) {
            showResultsButtonHome.appendChild(showResultsButton);
          }
        }
        const searchStatusMessage = document.getElementById(
          "searchStatusMessage"
        );
        if (searchStatusMessage) {
          searchStatusMessage.textContent = "";
          searchStatusMessage.classList.add("hidden");
        }
      }

      function resetLandingInputs() {
        const promptInput = document.getElementById("promptInput");
        if (promptInput) {
          promptInput.value = "";
        }

        isGeneratingDescription = true;
        descriptionEditor.setMarkdown("", false);
        isGeneratingDescription = false;
        if (descriptionTextarea) {
          descriptionTextarea.value = "";
        }

        currentTerms = {
          deviceTerms: [],
          technologyTerms: [],
          subjectTerms: [],
        };
        scoreThreshold = 60;
        progressTotalCandidates = null;
        progressAnalyzedCount = 0;
        currentProgressPercent = 0;
        latestProgressMessage = "";
        renderedTermNodes.device.clear();
        renderedTermNodes.subject.clear();
        relatedTermsCache = {};
        lastSearchQuery = "";
        lastTopK = 100;
        updateQueryPreview();
        hideTermAddButtons();

        currentHoverTerm = null;
        clearTimeout(addTermDebounceTimeout);
        addTermDebounceTimeout = null;
        clearTimeout(popoverTimeout);
        popoverTimeout = null;
        hidePopover();

        const popover = document.getElementById("termPopover");
        if (popover) {
          popover.classList.remove("show");
        }

        adjustEditorHeight();
      }

      function scrollToSelectorWithOffset(selector) {
        const targetElement = document.querySelector(selector);
        if (!targetElement) {
          return;
        }
        const navHeight = landingNav ? landingNav.offsetHeight : 0;
        const additionalOffset = 16;
        const targetPosition =
          targetElement.getBoundingClientRect().top + window.pageYOffset;
        const scrollTarget = Math.max(
          targetPosition - navHeight - additionalOffset,
          0
        );
        window.scrollTo({ top: scrollTarget, behavior: "smooth" });
      }

      function restoreLandingView(afterRestore) {
        cancelActiveGeneration();
        cancelActiveSearch();
        resetLandingInputs();

        const runAfterFrame = () => {
          if (typeof afterRestore === "function") {
            requestAnimationFrame(() => {
              requestAnimationFrame(afterRestore);
            });
          }
        };

        if (!hasUnlockedInterface) {
          runAfterFrame();
          return;
        }

        if (header) {
          header.classList.remove("content-visible");
        }
        if (main) {
          main.classList.remove("app-visible");
        }
        if (landingContentWrapper) {
          landingContentWrapper.classList.remove("hidden", "fade-out");
          landingContentWrapper.style.removeProperty("display");
          landingContentWrapper.style.display = "flex";
          landingContentWrapper.style.flexDirection = "column";
        }
        if (discoverSection) {
          discoverSection.classList.remove("hidden", "fade-out");
        }
        if (mainContent) {
          mainContent.classList.add("hidden");
          mainContent.classList.remove("fade-in");
        }
        if (descriptionSection) {
          descriptionSection.classList.add("hidden");
        }
        if (postGenerateColumn) {
          postGenerateColumn.classList.add("hidden");
        }

        hasUnlockedInterface = false;
        runAfterFrame();
      }

      navAnchorLinks.forEach((link) => {
        link.addEventListener("click", (event) => {
          const targetSelector = link.getAttribute("href");
          if (!targetSelector || !targetSelector.startsWith("#")) {
            return;
          }

          const targetElement = document.querySelector(targetSelector);
          if (!targetElement) {
            return;
          }

          event.preventDefault();

          const isLandingTarget =
            (landingContentWrapper &&
              landingContentWrapper.contains(targetElement)) ||
            (discoverSection && discoverSection.contains(targetElement));

          if (isLandingTarget) {
            restoreLandingView(() =>
              scrollToSelectorWithOffset(targetSelector)
            );
            return;
          }

          scrollToSelectorWithOffset(targetSelector);
        });
      });

      const INVENTION_IMAGE_FALLBACK =
        "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'%3E%3Crect width='200' height='200' fill='%23f3f4f6'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' fill='%239ca3af' font-family='sans-serif' font-size='18'%3ENo Image%3C/text%3E%3C/svg%3E";

      const INVENTIONS = [
        {
          slug: "smart-water-bottle",
          title: "Smart Water Bottle",
          categories: ["featured", "smart-home"],
          image:
            "{{ url_for('static', path='discover/smart-water-bottle.png') }}",
        },
        {
          slug: "smart-toaster",
          title: "Smart Toaster",
          categories: ["featured", "smart-home", "manufacturing"],
          image: "{{ url_for('static', path='discover/smart-toaster.png') }}",
        },
        {
          slug: "smart-thermostat",
          title: "Smart Thermostat Hub",
          categories: ["featured", "smart-home"],
          image:
            "{{ url_for('static', path='discover/smart-thermostat.png') }}",
        },
        {
          slug: "smart-refrigerator",
          title: "Smart Refrigerator with Display",
          categories: ["featured", "smart-home"],
          image:
            "{{ url_for('static', path='discover/smart-refridgerator.png') }}",
        },
        {
          slug: "laundry-machine-screen",
          title: "Laundry Machine with Interactive Screen",
          categories: ["smart-home", "manufacturing"],
          image:
            "{{ url_for('static', path='discover/laundry-machine-with-screen.png') }}",
        },
        {
          slug: "futuristic-workout-bike",
          title: "Connected Workout Bike",
          categories: ["featured", "smart-home"],
          image:
            "{{ url_for('static', path='discover/futuristic-workout-bike.png') }}",
        },
        {
          slug: "clothes-folding-robot",
          title: "Clothes Folding Robot",
          categories: ["manufacturing"],
          image:
            "{{ url_for('static', path='discover/clothes-folding-robot.png') }}",
        },
        {
          slug: "futuristic-bus",
          title: "Autonomous Transit Bus",
          categories: ["automotive", "featured"],
          image:
            "{{ url_for('static', path='discover/futuristic-bus.png') }}",
        },
      ];

      const discoverTabs = document.querySelectorAll(".discover-tab");
      const inventionGrid = document.getElementById("inventionGrid");

      function setActiveDiscoverTab(targetCategory) {
        discoverTabs.forEach((tab) => {
          const isActive =
            tab.dataset.category === targetCategory ||
            (!targetCategory && tab.dataset.category === "featured");
          tab.classList.toggle("is-active", isActive);
        });
      }

      function renderInventions(categoryKey = "featured") {
        if (!inventionGrid) return;
        inventionGrid.innerHTML = "";

        const normalizedKey = categoryKey || "featured";
        const items = INVENTIONS.filter((item) => {
          if (!Array.isArray(item.categories)) return false;
          return item.categories.includes(normalizedKey);
        });

        if (items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "invention-empty";
          empty.textContent =
            "No inventions in this category yet. Check back soon.";
          inventionGrid.appendChild(empty);
          return;
        }

        const fragment = document.createDocumentFragment();
        items.forEach((item) => {
          const itemWrapper = document.createElement("div");
          itemWrapper.className = "invention-item";
          itemWrapper.dataset.slug = item.slug;

          const card = document.createElement("div");
          card.className = "invention-card";

          const image = document.createElement("img");
          image.loading = "lazy";
          image.alt = item.title;
          image.src = item.image || INVENTION_IMAGE_FALLBACK;
          image.addEventListener("error", () => {
            image.onerror = null;
            image.src = INVENTION_IMAGE_FALLBACK;
          });

          const overlay = document.createElement("div");
          overlay.className = "invention-overlay";
          overlay.setAttribute("aria-hidden", "true");

          const cta = document.createElement("button");
          cta.type = "button";
          cta.className = "invention-action";
          cta.textContent = "Discover Patents";
          cta.addEventListener("click", () => startDiscoverSearch(item.title));
          overlay.appendChild(cta);

          card.appendChild(image);
          card.appendChild(overlay);

          const label = document.createElement("div");
          label.className = "invention-label";
          label.textContent = item.title;

          itemWrapper.appendChild(card);
          itemWrapper.appendChild(label);
          fragment.appendChild(itemWrapper);
        });

        inventionGrid.appendChild(fragment);
      }

      function startDiscoverSearch(title) {
        if (typeof title !== "string" || title.trim() === "") {
          return;
        }
        const promptInput = document.getElementById("promptInput");
        if (promptInput) {
          promptInput.value = title;
        }
        generateDescription();
      }

      function initializeDiscoverSection() {
        if (!discoverTabs.length || !inventionGrid) return;
        discoverTabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            const category = tab.dataset.category || "featured";
            setActiveDiscoverTab(category);
            renderInventions(category);
          });
        });
        setActiveDiscoverTab("featured");
        renderInventions("featured");
      }

      Object.entries(addTermButtons).forEach(([category, button]) => {
        if (!button) return;
        button.addEventListener("click", (e) =>
          showAddTermPopover(e.currentTarget, category)
        );
      });

      const descriptionTextarea = document.getElementById("userDescription");
      const descriptionEditor = new toastui.Editor({
        el: document.getElementById("descriptionEditor"),
        height: "420px",
        initialEditType: "wysiwyg",
        previewStyle: "vertical",
        hideModeSwitch: true,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
        ],
        initialValue: descriptionTextarea ? descriptionTextarea.value : "",
      });
      let isGeneratingDescription = false;
      let searchQueueToken = null;
      let searchCancellationRequested = false;

      const queueStatusBanner = document.getElementById("queueStatusBanner");
      const queueStatusText = document.getElementById("queueStatusText");

      function showQueueStatus(position) {
        if (!queueStatusBanner || !queueStatusText) return;
        const count =
          typeof position === "number" && Number.isFinite(position)
            ? Math.max(0, Math.floor(position))
            : null;
        let message;
        if (count === null) {
          message = "Please wait. Your search request is in the queue.";
        } else if (count <= 0) {
          message = "Please wait. Preparing to start your search.";
        } else if (count === 1) {
          message = "Please wait. There is 1 search ahead of you.";
        } else {
          message = `Please wait. There are ${count} searches ahead of you.`;
        }
        queueStatusText.textContent = message;
        queueStatusBanner.classList.remove("hidden");
      }

      function hideQueueStatus() {
        if (!queueStatusBanner || !queueStatusText) return;
        queueStatusText.textContent = "";
        queueStatusBanner.classList.add("hidden");
      }

      function waitForQueueDelay(position) {
        const base = 2000;
        const perItem = 1000;
        const extra =
          typeof position === "number" && Number.isFinite(position)
            ? Math.max(0, position) * perItem
            : 0;
        const waitMs = Math.min(12000, base + extra);
        return new Promise((resolve) => setTimeout(resolve, waitMs));
      }

      let adjustHeightFrame = null;
      function adjustEditorHeight() {
        if (adjustHeightFrame) {
          cancelAnimationFrame(adjustHeightFrame);
        }
        adjustHeightFrame = requestAnimationFrame(() => {
          const editorRoot = document.getElementById("descriptionEditor");
          if (!editorRoot) return;
          const defaultUI = editorRoot.querySelector(
            ".toastui-editor-defaultUI"
          );
          if (!defaultUI) return;

          const main = defaultUI.querySelector(".toastui-editor-main");
          if (!main) return;

          defaultUI.style.height = "auto";
          main.style.height = "auto";

          const toolbar = defaultUI.querySelector(".toastui-editor-toolbar");
          const modeSwitch = defaultUI.querySelector(
            ".toastui-editor-mode-switch"
          );
          const toolbarHeight = toolbar ? toolbar.offsetHeight : 0;
          const modeSwitchHeight = modeSwitch ? modeSwitch.offsetHeight : 0;

          const contentHeight = main.scrollHeight;
          const extraPadding = 32;
          const targetHeight = Math.max(
            contentHeight + toolbarHeight + modeSwitchHeight + extraPadding,
            MIN_EDITOR_HEIGHT
          );
          descriptionEditor.setHeight(`${targetHeight}px`);
        });
      }

      if (descriptionTextarea) {
        descriptionTextarea.value = descriptionEditor.getMarkdown();
      }

      descriptionEditor.on("change", () => {
        const markdown = descriptionEditor.getMarkdown();
        if (descriptionTextarea) {
          descriptionTextarea.value = markdown;
        }
        if (isGeneratingDescription) {
          return;
        }
        clearTimeout(extractTimeout);
        extractTimeout = setTimeout(() => {
          extractTerms(markdown);
        }, 2000);
        adjustEditorHeight();
      });

      descriptionEditor.on("keydown", (event) => {
        if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
          startSearch();
        }
      });
      adjustEditorHeight();

      const STRIPE_CHECKOUT_URL = "https://buy.stripe.com/YOUR_CHECKOUT_LINK";

      function unlockPremium() {
        window.location.href = STRIPE_CHECKOUT_URL;
      }

      // --- START: CORRECTED FUNCTION ---
      function showFullInterface() {
        if (hasUnlockedInterface) return;
        hasUnlockedInterface = true;

        // Apply global state changes
        if (header) {
          header.classList.add('content-visible');
        }
        if (main) {
          main.classList.add('app-visible');
        }

        const revealInterface = () => {
          if (landingContentWrapper) {
            landingContentWrapper.classList.add('hidden');
            landingContentWrapper.style.setProperty('display', 'none', 'important')
          }
          if (discoverSection) {
            discoverSection.classList.add('hidden');
          }

          if (mainContent) {
            mainContent.classList.remove('hidden');
            mainContent.classList.add('fade-in');
          }
          if (descriptionSection) {
            descriptionSection.classList.remove('hidden');
          }
          if (postGenerateColumn) {
            postGenerateColumn.classList.remove('hidden');
          }
          
          adjustEditorHeight();

          // Scroll the new content into view smoothly
          requestAnimationFrame(() => {
            if (mainContent) {
              mainContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          });
        };

        // Start the fade-out animation on the initial elements
        if (landingContentWrapper) {
          landingContentWrapper.classList.add('fade-out');
        }
        if (discoverSection) {
          discoverSection.classList.add('fade-out');
        }

        // Set a timer to match the CSS transition duration (0.4s)
        setTimeout(revealInterface, 400);
      }
      // --- END: CORRECTED FUNCTION ---

      async function fetchTotalPatents() {
        showIndexedCountLoading();
        try {
          const res = await fetch(`${API_BASE}/api/stats`);
          if (!res.ok) throw new Error(`Status ${res.status}`);
          const data = await res.json();
          const total = data?.totalPatents;
          let numericTotal = null;
          if (typeof total === "number" && Number.isFinite(total)) {
            numericTotal = total;
          } else if (typeof total === "string" && total.trim() !== "") {
            const parsed = Number.parseInt(total.replace(/,/g, ""), 10);
            if (!Number.isNaN(parsed)) {
              numericTotal = parsed;
            }
          }

          if (numericTotal !== null) {
            totalPatentsDisplay = numericTotal.toLocaleString();
            animateIndexedCount(numericTotal);
          } else {
            totalPatentsDisplay = null;
            resetIndexedCountBadge();
          }
        } catch (err) {
          console.warn("Failed to fetch total patent count:", err);
          totalPatentsDisplay = null;
          resetIndexedCountBadge();
        }
      }

      function showIndexedCountLoading() {
        if (indexedCountAnimationFrame) {
          cancelAnimationFrame(indexedCountAnimationFrame);
          indexedCountAnimationFrame = null;
        }
        if (indexedCountBadge) {
          indexedCountBadge.classList.add("loading");
          indexedCountBadge.dataset.countValue = "0";
        }
        if (indexedCountText) {
          indexedCountText.classList.remove("is-visible");
          indexedCountText.textContent = "Patents Indexed";
        }
      }

      function resetIndexedCountBadge() {
        showIndexedCountLoading();
      }

      function animateIndexedCount(targetValue) {
        if (!indexedCountBadge || !indexedCountText) return;
        const previousValueRaw = Number.parseInt(
          indexedCountBadge.dataset.countValue || "0",
          10
        );
        const defaultStart = Math.max(targetValue - INDEX_COUNT_OFFSET, 0);
        let startValue = Number.isFinite(previousValueRaw)
          ? previousValueRaw
          : defaultStart;
        startValue = Math.min(
          targetValue,
          Math.max(startValue, defaultStart)
        );

        if (indexedCountAnimationFrame) {
          cancelAnimationFrame(indexedCountAnimationFrame);
        }

        if (startValue === targetValue) {
          indexedCountBadge.dataset.countValue = String(targetValue);
          indexedCountBadge.classList.remove("loading");
          indexedCountText.classList.add("is-visible");
          indexedCountText.textContent = `${targetValue.toLocaleString()} Patents Indexed`;
          return;
        }

        indexedCountBadge.dataset.countValue = String(startValue);
        indexedCountBadge.classList.remove("loading");
        indexedCountText.classList.add("is-visible");
        indexedCountText.textContent = `${startValue.toLocaleString()} Patents Indexed`;

        const duration = 1300;
        const startTime = performance.now();

        const step = (now) => {
          const elapsed = Math.min((now - startTime) / duration, 1);
          const eased = 1 - Math.pow(1 - elapsed, 3);
          const current = Math.round(
            startValue + (targetValue - startValue) * eased
          );
          indexedCountText.textContent = `${current.toLocaleString()} Patents Indexed`;
          indexedCountBadge.dataset.countValue = String(current);
          if (elapsed < 1) {
            indexedCountAnimationFrame = requestAnimationFrame(step);
          } else {
            indexedCountAnimationFrame = null;
          }
        };

        indexedCountAnimationFrame = requestAnimationFrame(step);
      }

      async function generateDescription() {
        const promptInput = document.getElementById("promptInput");
        const prompt = promptInput ? promptInput.value.trim() : "";
        const btn = document.getElementById("generateBtn");

        if (!prompt) {
          alert("Please enter a brief description of your invention.");
          return;
        }

        cancelActiveGeneration();
        showFullInterface();
        const indicator = document.getElementById("generatingIndicator");
        if (indicator) {
          indicator.classList.remove("hidden");
          indicator.setAttribute("aria-hidden", "false");
        }

        btn.disabled = true;
        btn.textContent = "Creating descriptionâ€¦";
        isGeneratingDescription = true;
        let generatedMarkdown = "";
        let aborted = false;
        const controller = new AbortController();
        descriptionAbortController = controller;
        try {
          descriptionEditor.setMarkdown("", false);
          if (descriptionTextarea) {
            descriptionTextarea.value = "";
          }
          adjustEditorHeight();

          const response = await fetch(`${API_BASE}/api/generate-description`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ prompt }),
            signal: controller.signal,
          });

          if (!response.ok || !response.body) {
            throw new Error(`Failed with status ${response.status}`);
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            generatedMarkdown += decoder.decode(value, { stream: true });
            descriptionEditor.setMarkdown(generatedMarkdown, false);
            if (descriptionTextarea) {
              descriptionTextarea.value = generatedMarkdown;
            }
            adjustEditorHeight();
          }
          if (!controller.signal.aborted) {
            generatedMarkdown += decoder.decode();
            descriptionEditor.setMarkdown(generatedMarkdown, false);
            if (descriptionTextarea) {
              descriptionTextarea.value = generatedMarkdown;
            }
            adjustEditorHeight();
          }
        } catch (err) {
          if (err && err.name === "AbortError") {
            aborted = true;
          } else {
            console.error("Error:", err);
            alert("Failed to generate description");
          }
        } finally {
          if (descriptionAbortController === controller) {
            descriptionAbortController = null;
          }
          isGeneratingDescription = false;
          btn.disabled = false;
          btn.textContent = "Search for free";
          if (indicator) {
            indicator.classList.add("hidden");
            indicator.setAttribute("aria-hidden", "true");
          }
        }

        if (!aborted && generatedMarkdown) {
          extractTerms(generatedMarkdown);
        }
      }

      async function extractTerms(text) {
        if (!text || text.trim().length < 20) {
          currentTerms = {
            deviceTerms: [],
            technologyTerms: [],
            subjectTerms: [],
          };
          updateQueryPreview();
          return;
        }

        document
          .getElementById("extractingIndicator")
          .classList.remove("hidden");

        try {
          const response = await fetch(`${API_BASE}/api/extract-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ documentText: text }),
          });

          if (response.ok) {
            currentTerms = await response.json();
            updateQueryPreview();
            preloadRelatedTerms();
          }
        } catch (err) {
          console.error("Error:", err);
        } finally {
          document
            .getElementById("extractingIndicator")
            .classList.add("hidden");
        }
      }

      async function preloadRelatedTerms() {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];

        const termsToFetch = allTerms.filter((t) => !relatedTermsCache[t]);
        if (termsToFetch.length === 0) return;

        try {
          const response = await fetch(`${API_BASE}/api/get-related-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: termsToFetch }),
          });

          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn("Failed to fetch related terms:", err);
        }
      }

      function formatProgressMessage(message) {
        if (!message) return "";
        return message.replace(/^\[[^\]]+\]\s*/, "").trim();
      }

      function setSearchProgress(percent, message) {
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;

        if (Number.isFinite(percent)) {
          currentProgressPercent = Math.max(
            0,
            Math.min(100, Math.round(percent))
          );
        }

        if (message) {
          latestProgressMessage = formatProgressMessage(message);
        }

        bar.style.width = `${currentProgressPercent}%`;
        text.textContent = latestProgressMessage;
        container.classList.remove("hidden");
      }

      function resetSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        progressTotalCandidates = null;
        progressAnalyzedCount = 0;
        currentProgressPercent = 0;
        latestProgressMessage = "Starting search...";
        setSearchProgress(5, latestProgressMessage);
      }

      function hideSearchProgress() {
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
          progressHideTimeout = null;
        }
        const container = document.getElementById("searchProgress");
        const bar = document.getElementById("searchProgressBar");
        const text = document.getElementById("searchProgressMessage");
        if (!container || !bar || !text) return;
        currentProgressPercent = 0;
        latestProgressMessage = "";
        bar.style.width = "0%";
        text.textContent = "";
        container.classList.add("hidden");
      }

      function updateSearchProgressFromLog(message) {
        if (!message) return;
        const cleanMessage = formatProgressMessage(message);
        let percent = null;

        if (/starting search/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 5);
        } else if (/finding candidate/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 12);
        } else if (/found\s+(\d+)\s+candidates?/i.test(cleanMessage)) {
          const match = cleanMessage.match(/found\s+(\d+)\s+candidates?/i);
          if (match) {
            progressTotalCandidates = parseInt(match[1], 10) || null;
            progressAnalyzedCount = 0;
          }
          percent = Math.max(currentProgressPercent, 20);
        } else if (/processed\s+(\d+)\s*\/\s*(\d+)/i.test(cleanMessage)) {
          const match = cleanMessage.match(/processed\s+(\d+)\s*\/\s*(\d+)/i);
          if (match) {
            progressAnalyzedCount = parseInt(match[1], 10) || 0;
            const total = parseInt(match[2], 10) || progressTotalCandidates;
            if (total) {
              progressTotalCandidates = total;
              const ratio = Math.max(
                0,
                Math.min(1, progressAnalyzedCount / total)
              );
              percent = Math.max(currentProgressPercent, 20 + ratio * 75);
            }
          }
        } else if (/finished analysis/i.test(cleanMessage)) {
          percent = Math.max(currentProgressPercent, 95);
        }

        setSearchProgress(percent, cleanMessage);
      }

      function handleSearchComplete(data) {
        let message = "Search complete";
        if (data && typeof data.analyzed === "number") {
          progressAnalyzedCount = data.analyzed;
        }
        if (data && typeof data.results === "number") {
          message = `${message} - ${data.results} result${
            data.results === 1 ? "" : "s"
          }`;
        }
        if (progressTotalCandidates && progressAnalyzedCount) {
          message = `${message} (${progressAnalyzedCount} analyzed)`;
        }

        setSearchProgress(100, message);
        if (progressHideTimeout) {
          clearTimeout(progressHideTimeout);
        }
        progressHideTimeout = setTimeout(() => {
          hideSearchProgress();
          progressHideTimeout = null;
        }, 1200);
      }

      function updateQueryPreview() {
        const hasTerms =
          currentTerms.deviceTerms.length > 0 ||
          currentTerms.technologyTerms.length > 0 ||
          currentTerms.subjectTerms.length > 0;

        document
          .getElementById("emptyState")
          .classList.toggle("hidden", hasTerms);
        document
          .getElementById("queryPreview")
          .classList.toggle("hidden", !hasTerms);

        const searchButton = document.getElementById("searchButton");
        if (searchButton) {
          searchButton.classList.toggle("hidden", !hasTerms);
        }

        const combinedTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
        ];
        const sortedDeviceTerms = combinedTerms
          .slice()
          .sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: "base" })
          );
        const sortedSubjectTerms = currentTerms.subjectTerms
          .slice()
          .sort((a, b) =>
            a.localeCompare(b, undefined, { sensitivity: "base" })
          );

        renderTerms("deviceTechTerms", sortedDeviceTerms, "device");
        renderTerms("subjectTerms", sortedSubjectTerms, "subject");
      }

      function createTermBadge(term) {
        const badge = document.createElement("span");
        badge.className = "term-badge term-enter";
        badge.dataset.term = term;

        const removeButton = document.createElement("span");
        removeButton.className = "term-remove";
        removeButton.textContent = "Ã—";
        removeButton.addEventListener("click", (event) => {
          event.stopPropagation();
          removeTerm(term);
        });

        badge.appendChild(removeButton);
        badge.appendChild(document.createTextNode(term));

        badge.addEventListener("mouseenter", (e) =>
          showHoverPopover(e.currentTarget, term)
        );
        badge.addEventListener("mouseleave", hidePopover);
        badge.addEventListener("animationend", () =>
          badge.classList.remove("term-enter")
        );

        return badge;
      }

      function renderTerms(containerId, terms, category) {
        const container = document.getElementById(containerId);
        if (!container) return;
        const registry =
          renderedTermNodes[category] ||
          (renderedTermNodes[category] = new Map());

        if (!Array.isArray(terms) || terms.length === 0) {
          container.textContent = "";
          registry.clear();
          return;
        }

        const seen = new Set();
        const fragment = document.createDocumentFragment();

        terms.forEach((term, index) => {
          let badge = registry.get(term);
          if (!badge) {
            badge = createTermBadge(term);
            registry.set(term, badge);
            badge.style.setProperty("--term-delay", `${index * 0.08}s`);
          } else {
            badge.classList.remove("term-enter");
            badge.style.removeProperty("--term-delay");
          }
          seen.add(term);
          fragment.appendChild(badge);
          if (index < terms.length - 1) {
            fragment.appendChild(document.createTextNode(",\u00A0"));
          }
        });

        Array.from(registry.keys()).forEach((term) => {
          if (!seen.has(term)) {
            registry.delete(term);
          }
        });

        container.textContent = "";
        container.appendChild(fragment);

        const addButton = addTermButtons[category];
        if (addButton) {
          addButton.classList.remove("hidden");
        }
      }

      function positionPopover(targetElement) {
        const popover = document.getElementById("termPopover");
        if (!targetElement || !popover) return;

        const rect = targetElement.getBoundingClientRect();
        const scrollX = window.scrollX;
        const scrollY = window.scrollY;

        const top = rect.bottom + scrollY;
        const left = rect.left + scrollX;

        popover.style.left = `${left}px`;
        popover.style.top = `${top}px`;
      }

      function showAddTermPopover(buttonElement, category) {
        clearTimeout(popoverTimeout);
        popoverContext = { mode: "add", category: category };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const input = document.getElementById("addTermInput");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.add("hidden");
        addSection.classList.remove("hidden");
        relatedContainer.innerHTML = "";
        input.value = "";

        positionPopover(buttonElement);

        popover.classList.add("show");
        input.focus();

        input.oninput = () => {
          clearTimeout(addTermDebounceTimeout);
          addTermDebounceTimeout = setTimeout(() => {
            const term = input.value.trim();
            if (term) {
              fetchAndDisplayRelated(term, relatedContainer);
            } else {
              relatedContainer.innerHTML = "";
            }
          }, 500);
        };

        input.onkeydown = (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            const term = input.value.trim();
            if (term) {
              addRelatedTerm(term);
              hidePopover();
            }
          }
        };

        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      async function fetchAndDisplayRelated(term, container) {
        container.innerHTML =
          '<span style="font-size: 0.75rem; color: #9ca3af;">Loadingâ€¦</span>';

        if (!relatedTermsCache[term]) {
          await fetchRelatedForSingleTerm(term);
        }

        const related = relatedTermsCache[term] || [];
        container.innerHTML = "";

        if (related.length === 0) {
          container.innerHTML =
            '<span style="font-size: 0.75rem; color: #9ca3af;">No suggestions found.</span>';
        } else {
          related.forEach((relTerm) => {
            const badge = document.createElement("span");
            badge.className = "related-badge";
            badge.textContent = relTerm;
            badge.onclick = () => addRelatedTerm(relTerm);
            container.appendChild(badge);
          });
        }
      }

      function showHoverPopover(badgeElement, term) {
        clearTimeout(popoverTimeout);
        currentHoverTerm = term;
        popoverContext = { mode: "hover" };

        const popover = document.getElementById("termPopover");
        const addSection = document.getElementById("popoverAddSection");
        const hoverTitle = document.getElementById("popoverHoverTitle");
        const relatedContainer = document.getElementById(
          "relatedTermsContainer"
        );

        hoverTitle.classList.remove("hidden");
        addSection.classList.add("hidden");

        positionPopover(badgeElement);

        fetchAndDisplayRelated(term, relatedContainer);

        popover.classList.add("show");
        popover.addEventListener("mouseenter", () =>
          clearTimeout(popoverTimeout)
        );
        popover.addEventListener("mouseleave", hidePopover);
      }

      function hidePopover() {
        popoverTimeout = setTimeout(() => {
          document.getElementById("termPopover").classList.remove("show");
        }, 200);
      }

      async function fetchRelatedForSingleTerm(term) {
        if (relatedTermsCache[term]) return;
        try {
          const response = await fetch(`${API_BASE}/api/get-related-terms`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ terms: [term] }),
          });
          if (response.ok) {
            const newRelated = await response.json();
            relatedTermsCache = { ...relatedTermsCache, ...newRelated };
          }
        } catch (err) {
          console.warn(`Failed to fetch related terms for ${term}:`, err);
        }
      }

      function addRelatedTerm(term) {
        const allTerms = [
          ...currentTerms.deviceTerms,
          ...currentTerms.technologyTerms,
          ...currentTerms.subjectTerms,
        ];
        if (allTerms.includes(term)) {
          return;
        }

        if (popoverContext.mode === "add") {
          if (popoverContext.category === "subject") {
            currentTerms.subjectTerms.push(term);
          } else if (popoverContext.category === "device") {
            currentTerms.deviceTerms.push(term);
          } else {
            console.error(
              "addRelatedTerm called in 'add' mode with unknown category:",
              popoverContext.category
            );
            return;
          }
        } else if (popoverContext.mode === "hover" && currentHoverTerm) {
          if (
            currentTerms.deviceTerms.includes(currentHoverTerm) ||
            currentTerms.technologyTerms.includes(currentHoverTerm)
          ) {
            currentTerms.deviceTerms.push(term);
          } else if (currentTerms.subjectTerms.includes(currentHoverTerm)) {
            currentTerms.subjectTerms.push(term);
          }
        } else {
          console.error(
            "addRelatedTerm called in an unknown or invalid state:",
            popoverContext
          );
          return;
        }

        updateQueryPreview();

        if (popoverContext.mode === "hover") {
          hidePopover();
        }
      }

      function removeTerm(term) {
        currentTerms.deviceTerms = currentTerms.deviceTerms.filter(
          (t) => t !== term
        );
        currentTerms.technologyTerms = currentTerms.technologyTerms.filter(
          (t) => t !== term
        );
        currentTerms.subjectTerms = currentTerms.subjectTerms.filter(
          (t) => t !== term
        );
        updateQueryPreview();
      }

      function cleanTextForSearch(text) {
        return text
          .replace(/^#+\s+/gm, "")
          .replace(/\*\*/g, "")
          .replace(/\*/g, "")
          .replace(/__/g, "")
          .replace(/_/g, "")
          .replace(/^\d+\.\s+/gm, "")
          .replace(/^[-â€¢]\s+/gm, "")
          .replace(/\n\n+/g, " ")
          .replace(/\n/g, " ")
          .replace(/\s+/g, " ")
          .trim();
      }

      function resetResultsView() {
        if (showResultsButton) {
          showResultsButton.disabled = false;
          showResultsButton.textContent = "Show results";
          showResultsButton.dataset.available = "false";
          showResultsButton.classList.add("hidden");
          if (
            showResultsButtonHome &&
            showResultsButton.parentElement !== showResultsButtonHome
          ) {
            showResultsButtonHome.appendChild(showResultsButton);
          }
        }
        if (downloadButtonEl) {
          downloadButtonEl.classList.add("hidden");
          downloadButtonEl.dataset.available = "false";
        }
        if (resultsContainerEl) {
          resultsContainerEl.classList.add("hidden");
          resultsContainerEl.innerHTML = "";
        }
        if (mainContent) {
          mainContent.classList.remove("hidden");
        }
      }

      function showResultsView() {
        if (!showResultsButton) return;

        if (mainContent) {
          mainContent.classList.add("hidden");
        }
        if (resultsContainerEl) {
          resultsContainerEl.classList.remove("hidden");
          resultsContainerEl.scrollIntoView({
            behavior: "smooth",
            block: "start",
          });
        }
        if (downloadButtonEl) {
          if (downloadButtonEl.dataset.available === "true") {
            downloadButtonEl.classList.remove("hidden");
          } else {
            downloadButtonEl.classList.add("hidden");
          }
        }
        showResultsButton.classList.add("hidden");
      }

      function restoreSearchButton(button, options = {}) {
        if (!button) return;
        const { hideAfterRestore = false } = options;
        button.disabled = false;
        const resetLabel =
          button.dataset.defaultLabel || SEARCH_BUTTON_DEFAULT_LABEL;
        button.innerHTML = resetLabel;
        button.style.display = "";
        button.style.alignItems = "";
        button.style.justifyContent = "";
        button.style.gap = "";
        if (hideAfterRestore) {
          button.classList.add("hidden");
          hideTermAddButtons();
        }
      }

      async function startSearch() {
        const maxDisplayResultsInput =
          document.getElementById("maxDisplayResults");
        if (!maxDisplayResultsInput) {
          alert("Error: Could not find the 'topK' input element.");
          return;
        }
        const maxDisplayResults = parseInt(maxDisplayResultsInput.value, 10);

        const resultsContainer = resultsContainerEl;
        const searchButton = document.getElementById("searchButton");
        const downloadButton = downloadButtonEl;
        const searchStatusMessage = document.getElementById(
          "searchStatusMessage"
        );

        if (
          !resultsContainer ||
          !searchButton ||
          !downloadButton ||
          !searchStatusMessage ||
          !showResultsButton
        ) {
          console.error("Missing required elements");
          alert(
            "A critical UI element is missing. Please check the console for details."
          );
          return;
        }

        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }

        searchCancellationRequested = false;

        searchStatusMessage.classList.add("hidden");
        searchStatusMessage.textContent = "";

        searchButton.disabled = true;

        let searchQuery = "";
        const { deviceTerms, technologyTerms, subjectTerms } = currentTerms;
        const hasExtractedTerms =
          deviceTerms.length > 0 ||
          technologyTerms.length > 0 ||
          subjectTerms.length > 0;

        if (hasExtractedTerms) {
          const queryParts = [];
          const combinedTech = [...deviceTerms, ...technologyTerms];
          if (combinedTech.length > 0) {
            queryParts.push(
              `A patent describing a device or technology such as: ${combinedTech.join(
                " or "
              )}.`
            );
          }
          if (subjectTerms.length > 0) {
            queryParts.push(
              `Applied in the subject matter or field of: ${subjectTerms.join(
                " or "
              )}.`
            );
          }
          searchQuery = queryParts.join(" ");
        } else {
          const description = descriptionEditor.getMarkdown().trim();
          if (!description) {
            alert("You must generate terms from invention title first.");
            restoreSearchButton(searchButton);
            return;
          }
          searchQuery = cleanTextForSearch(description);
        }

        if (!searchQuery) {
          alert(
            "Could not build a search query. Please check your description."
          );
          restoreSearchButton(searchButton);
          return;
        }

        resetResultsView();

        if (searchCancellationRequested) {
          return;
        }

        console.log("Final Search Query:", searchQuery);
        lastSearchQuery = searchQuery;
        lastTopK = maxDisplayResults;

        resultsContainer.innerHTML =
          '<div class="loading"><div class="spinner"></div><p>Searching patents...</p></div>';
        resetSearchProgress();

        if (searchCancellationRequested) {
          return;
        }

        let resultCount = 0;
        let hasClearedPlaceholder = false;
        let hasCompleted = false;

        let queueToken = searchQueueToken;
        try {
          while (true) {
            if (searchCancellationRequested) {
              return;
            }
            let response;
            try {
              response = await fetch(`${API_BASE}/api/search/enqueue`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  userDescription: searchQuery,
                  maxDisplayResults,
                  queueToken,
                }),
              });
            } catch (err) {
              if (searchCancellationRequested) {
                return;
              }
              throw new Error("Unable to contact the search queue.");
            }

            if (searchCancellationRequested) {
              return;
            }

            if (response.status === 429) {
              let data = null;
              try {
                data = await response.json();
              } catch (parseErr) {
                console.warn("Unable to parse queue response:", parseErr);
              }
              const position =
                data && typeof data.queuePosition === "number"
                  ? data.queuePosition
                  : null;
              if (data && typeof data.queueToken === "string") {
                queueToken = data.queueToken;
                searchQueueToken = data.queueToken;
              }
              showQueueStatus(position);
              await waitForQueueDelay(position);
              if (searchCancellationRequested) {
                return;
              }
              continue;
            }

            if (!response.ok) {
              throw new Error(
                `Queue request failed (status ${response.status}).`
              );
            }

            let data = null;
            try {
              data = await response.json();
            } catch {
              data = null;
            }
            if (data && typeof data.queueToken === "string") {
              queueToken = data.queueToken;
            }
            searchQueueToken = queueToken || null;
            hideQueueStatus();
            break;
          }
          if (searchCancellationRequested) {
            return;
          }
        } catch (err) {
          console.error("Failed to reserve search slot:", err);
          hideQueueStatus();
          hideSearchProgress();
          restoreSearchButton(searchButton);
          searchStatusMessage.textContent =
            "Unable to start the search right now. Please try again in a moment.";
          searchStatusMessage.classList.remove("hidden");
          resultsContainer.innerHTML =
            '<div class="empty-state">Unable to start search. Please try again shortly.</div>';
          return;
        }

        const params = new URLSearchParams({
          userDescription: searchQuery,
          maxDisplayResults: String(maxDisplayResults),
        });
        if (queueToken) {
          params.set("queueToken", queueToken);
        }
        if (!queueToken) {
          console.error("Queue token missing after slot allocation.");
          hideQueueStatus();
          hideSearchProgress();
          searchQueueToken = null;
          searchStatusMessage.textContent =
            "Unable to start the search right now. Please try again in a moment.";
          searchStatusMessage.classList.remove("hidden");
          restoreSearchButton(searchButton);
          resultsContainer.innerHTML =
            '<div class="empty-state">Unable to start search. Please try again shortly.</div>';
          return;
        }

        if (searchCancellationRequested) {
          return;
        }

        const searchUrl = `${API_BASE}/api/search?${params.toString()}`;
        eventSource = new EventSource(searchUrl);
        eventSource.onopen = () => {
          if (searchCancellationRequested) {
            return;
          }
          hideQueueStatus();
        };

        eventSource.addEventListener("log", (event) => {
          if (searchCancellationRequested) {
            return;
          }
          try {
            const data = JSON.parse(event.data || "{}");
            updateSearchProgressFromLog(data.message || "");
          } catch (err) {
            console.warn("Failed to parse log event", err);
          }
        });

        eventSource.addEventListener("result", (event) => {
          if (searchCancellationRequested) {
            return;
          }
          try {
            const data = JSON.parse(event.data || "{}");
            const resultPayload = data.result;
            if (
              !resultPayload ||
              resultPayload.score === null ||
              resultPayload.score === undefined ||
              resultPayload.score < scoreThreshold
            ) {
              return;
            }

            if (!hasClearedPlaceholder) {
              resultsContainer.innerHTML = "";
              hasClearedPlaceholder = true;
            }

            if (addResult(resultPayload)) {
              resultCount++;
              searchStatusMessage.classList.add("hidden");
            }
          } catch (err) {
            console.warn("Failed to process result event", err);
          }
        });

        eventSource.addEventListener("complete", (event) => {
          if (searchCancellationRequested) {
            return;
          }
          if (hasCompleted) return;
          hasCompleted = true;

          let data = null;
          try {
            data = JSON.parse(event.data || "{}");
            handleSearchComplete(data);
          } catch (err) {
            console.warn("Failed to parse complete event", err);
            hideSearchProgress();
          }

          restoreSearchButton(searchButton, { hideAfterRestore: true });

          const hasResults = resultCount > 0;
          if (hasResults) {
            if (data && typeof data.score_threshold === "number") {
              scoreThreshold = data.score_threshold;
            }
            const highConfidenceCount =
              data && typeof data.high_confidence === "number"
                ? data.high_confidence
                : resultCount;
            const totalCandidates =
              data && typeof data.total_candidates === "number"
                ? data.total_candidates
                : highConfidenceCount;
            const corpusText = totalPatentsDisplay || "all patents";
            searchStatusMessage.textContent = `Found ${resultCount} highly relevant matches from ${corpusText} patents.`;
          } else {
            searchStatusMessage.textContent = `No results found with a score of ${scoreThreshold} or above. Select "Show results" to review the summary.`;
            resultsContainer.innerHTML = `<div class="empty-state">No results found with a score of ${scoreThreshold} or above.</div>`;
          }
          if (downloadButton) {
            downloadButton.dataset.available = hasResults ? "true" : "false";
            downloadButton.classList.add("hidden");
          }
          if (resultsContainer) {
            resultsContainer.classList.add("hidden");
          }
          if (showResultsButton) {
            showResultsButton.dataset.available = "true";
            showResultsButton.textContent = "Show results";
            if (
              showResultsButtonHome &&
              showResultsButton.parentElement !== showResultsButtonHome
            ) {
              showResultsButtonHome.appendChild(showResultsButton);
            }
            showResultsButton.classList.remove("hidden");
          }
          searchStatusMessage.classList.remove("hidden");

          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          searchQueueToken = null;
          hideQueueStatus();
        });

        eventSource.onerror = (event) => {
          if (searchCancellationRequested) {
            return;
          }
          if (hasCompleted) return;
          console.error("Search stream error:", event);
          hideSearchProgress();
          restoreSearchButton(searchButton);
          resultsContainer.innerHTML =
            '<div class="empty-state">An error occurred during the search. Please check the console.</div>';
          resultsContainer.classList.add("hidden");
          if (downloadButton) {
            downloadButton.dataset.available = "false";
            downloadButton.classList.add("hidden");
          }
          if (showResultsButton) {
            showResultsButton.dataset.available = "true";
            showResultsButton.textContent = "Show results";
            if (
              showResultsButtonHome &&
              showResultsButton.parentElement !== showResultsButtonHome
            ) {
              showResultsButtonHome.appendChild(showResultsButton);
            }
            showResultsButton.classList.remove("hidden");
          }
          searchStatusMessage.textContent =
            'Search failed. Select "Show results" to review the error and try again.';
          searchStatusMessage.classList.remove("hidden");
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          searchQueueToken = null;
          hideQueueStatus();
        };
      }

      function addResult(result) {
        const numericScore =
          typeof result.score === "number"
            ? result.score
            : Number.parseFloat(result.score);

        if (
          Number.isNaN(numericScore) ||
          numericScore === null ||
          numericScore === undefined ||
          numericScore < scoreThreshold
        ) {
          return false;
        }

        const resultsContainer = document.getElementById("resultsContainer");
        if (!resultsContainer) return false;

        const existingCards =
          resultsContainer.querySelectorAll(".result-item").length;
        if (existingCards >= lastTopK) {
          return false;
        }

        let scoreClass = "score-low";
        if (numericScore >= 95) {
          scoreClass = "score-high";
        } else if (numericScore >= scoreThreshold) {
          scoreClass = "score-medium";
        }

        const displayScore = Number.isInteger(numericScore)
          ? numericScore
          : numericScore.toFixed(2);

        const MAX_TITLE_LENGTH = 48;
        const title = result.title || "Untitled Patent";
        const displayTitle =
          title.length > MAX_TITLE_LENGTH
            ? `${title.slice(0, MAX_TITLE_LENGTH)}â€¦`
            : title;

        const resultItem = document.createElement("div");
        resultItem.className = "result-item";

        const titleEl = document.createElement("div");
        titleEl.className = "result-title";
        titleEl.textContent = displayTitle;
        resultItem.appendChild(titleEl);

        if (numericScore !== null && numericScore !== undefined) {
          const scoreWrapper = document.createElement("div");
          scoreWrapper.style.marginTop = "0.5rem";
          scoreWrapper.style.marginBottom = "0.5rem";

          const scoreBadge = document.createElement("span");
          scoreBadge.className = `score-badge ${scoreClass}`;
          scoreBadge.textContent = `Relevancy Rating: ${displayScore}`;

          scoreWrapper.appendChild(scoreBadge);
          resultItem.appendChild(scoreWrapper);
        }

        const abstractEl = document.createElement("div");
        abstractEl.className = "result-abstract";
        abstractEl.style.marginBottom = "0.75rem";
        abstractEl.textContent =
          result.preview || result.abstract || "No abstract available";
        resultItem.appendChild(abstractEl);

        const metaParts = [];
        const patentNumber =
          typeof result.patentNumber === "string"
            ? result.patentNumber
            : result.patentNumber != null
            ? String(result.patentNumber)
            : "";
        const filingDate =
          typeof result.filingDate === "string"
            ? result.filingDate
            : result.filingDate != null
            ? String(result.filingDate)
            : "";

        if (patentNumber) metaParts.push(patentNumber);
        if (filingDate) metaParts.push(filingDate);

        if (metaParts.length > 0) {
          const metaDiv = document.createElement("div");
          metaDiv.className = "result-meta";
          metaDiv.style.marginBottom = "0.5rem";

          const metaSpan = document.createElement("span");
          metaSpan.textContent = metaParts.join(" â€¢ ");
          metaDiv.appendChild(metaSpan);
          resultItem.appendChild(metaDiv);
        }

        const patentUrl =
          typeof result.googlePatentUrl === "string"
            ? result.googlePatentUrl.trim()
            : "";
        if (/^https?:\/\//i.test(patentUrl)) {
          const link = document.createElement("a");
          link.href = patentUrl;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.className = "result-link";
          link.textContent = "View patent";
          resultItem.appendChild(link);
        }

        resultsContainer.appendChild(resultItem);
        return true;
      }
      function downloadCSV() {
        const url = `${API_BASE}/export_csv?userDescription=${encodeURIComponent(
          lastSearchQuery
        )}&topK=${lastTopK}`;
        window.open(url, "_blank");
      }

      document
        .getElementById("promptInput")
        .addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            generateDescription();
          }
        });

      initializeDiscoverSection();

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", fetchTotalPatents);
      } else {
        fetchTotalPatents();
      }
    </script>
  </body>
</html>
